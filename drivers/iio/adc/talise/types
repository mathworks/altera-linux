/**
 * \file talise_agc_types.h
 * \brief Contains Talise API AGC data types
 *
 * Talise API version: 3.4.0.0
 *
 * Copyright 2015-2017 Analog Devices Inc.
 * Released under the AD9378-AD9379 API license, for more information see the "LICENSE.txt" file in this zip file.
 */

#ifndef TALISE_AGC_TYPES_H_
#define TALISE_AGC_TYPES_H_

#ifdef __cplusplus
extern "C" {
#endif

/**
 *  \brief Data structure to hold AGC peak settings
 *  The evaluation software GUI for the product can be used to generate a structure with suggested settings.
 */
typedef struct
{
    uint32_t    agcUnderRangeLowInterval_ns;        /*!< Update interval for AGC loop mode in nanoseconds */
    uint8_t     agcUnderRangeMidInterval;           /*!< 2nd update interval for multiple time constant AGC mode. Calculated as (agcUnderRangeMidInterval+1)*agcUnderRangeLowInterval_ns. Valid range is 0 to 63 */
    uint8_t     agcUnderRangeHighInterval;          /*!< 3rd update interval for multiple time constant AGC mode. Calculated as (agcUnderRangeHighInterval+1)*2nd update interval. Valid range is 0 to 63 */
    uint8_t     apdHighThresh;                      /*!< AGC APD high threshold. Valid range is 0 to 63 */
    uint8_t     apdLowGainModeHighThresh;           /*!< AGC APD high threshold in low gain mode. Valid range is 0 to 63. Recommended to be 3dB above apdHighThresh */
    uint8_t     apdLowThresh;                       /*!< AGC APD low threshold. Valid range is 0 to 63. Recommended to be 3dB below apdHighThresh */
    uint8_t     apdLowGainModeLowThresh;            /*!< AGC APD low threshold in low gain mode. Valid range is 0 to 63. Recommended to be 3dB above apdLowThresh */
    uint8_t     apdUpperThreshPeakExceededCnt;      /*!< AGC APD peak detect upper threshold count. Valid range is 0 to 255 */
    uint8_t     apdLowerThreshPeakExceededCnt;      /*!< AGC APD peak detect lower threshold count. Valid range is 0 to 255 */
    uint8_t     apdGainStepAttack;                  /*!< AGC APD peak detect attack gain step. Valid range is 0 to 31 */
    uint8_t     apdGainStepRecovery;                /*!< AGC APD gain index step size for recovery. Valid range is 0 to 31 */
    uint8_t     enableHb2Overload;                  /*!< Enable or disables the HB2 overload detector. */
    uint8_t     hb2OverloadDurationCnt;             /*!< Sets the window of clock cycles (at the HB2 output rate) to meet the overload count. (0 = 2 cycles, 1 = 4 cycles, 2 = 8 cycles, 3 = 12 cycles, 4 = 16 cycles, 5 = 24 cycles, 6 = 32 cycles) */
    uint8_t     hb2OverloadThreshCnt;               /*!< Sets the number of actual overloads required to trigger the overload signal. Valid range from 1 to 15 */
    uint8_t     hb2HighThresh;                      /*!< AGC HB2 output high threshold. Valid range from  0 to 255 */
    uint8_t     hb2UnderRangeLowThresh;             /*!< AGC HB2 output low threshold. Valid range from  0 to 255 */
    uint8_t     hb2UnderRangeMidThresh;             /*!< AGC HB2 output low threshold for 2nd interval for multiple time constant AGC mode. Valid range from  0 to 255 */
    uint8_t     hb2UnderRangeHighThresh;            /*!< AGC HB2 output low threshold for 3rd interval for multiple time constant AGC mode. Valid range from  0 to 255 */
    uint8_t     hb2UpperThreshPeakExceededCnt;      /*!< AGC HB2 output upper threshold count. Valid range from  0 to 255 */
    uint8_t     hb2LowerThreshPeakExceededCnt;      /*!< AGC HB2 output lower threshold count. Valid range from  0 to 255 */
    uint8_t     hb2GainStepHighRecovery;            /*!< AGC HB2 gain index step size. Valid range from  0 to 31 */
    uint8_t     hb2GainStepLowRecovery;             /*!< AGC HB2 gain index step size, when the HB2 Low Overrange interval 2 triggers. Valid range from  0 to 31 */
    uint8_t     hb2GainStepMidRecovery;             /*!< AGC HB2 gain index step size, when the HB2 Low Overrange interval 3 triggers. Valid range from  0 to 31 */
    uint8_t     hb2GainStepAttack;                  /*!< AGC HB2 output attack gain step. Valid range from  0 to 31 */
    uint8_t     hb2OverloadPowerMode;               /*!< When this bit is set, the dynamic range of the power measurement increases from -40dB to ~-60dB (that is, all signal levels from 0dBFS to -60dBFS are accurately detected */
    uint8_t     hb2OvrgSel;                         /*!< To be used in fast recovery mode. Clearing this bit enables the decimated data overload detection functionality */
    uint8_t     hb2ThreshConfig;                    /*!< Not User Modifiable   Initialized to 0x03 */

} taliseAgcPeak_t;

/**
 * \brief Data structure to hold AGC power settings
 *  The evaluation software GUI for the product can be used to generate a structure with suggested settings.
 */
typedef struct
{
    uint8_t     powerEnableMeasurement;                 /*!< Enable the Rx power measurement block. (0/1) */
    uint8_t     powerUseRfirOut;                        /*!< Use output of Rx PFIR for power measurement. (0/1) */
    uint8_t     powerUseBBDC2;                          /*!< Use output of DC offset block for power measurement. (0/1) */
    uint8_t     underRangeHighPowerThresh;              /*!< AGC power measurement detect lower 0 threshold. Valid Range from 0 to 127. */
    uint8_t     underRangeLowPowerThresh;               /*!< AGC power measurement detect lower 1 threshold. Valid offset from 0 to 31 */
    uint8_t     underRangeHighPowerGainStepRecovery;    /*!< AGC power measurement detect lower 0 recovery gain step. Valid range from  0 to 31 */
    uint8_t     underRangeLowPowerGainStepRecovery;     /*!< AGC power measurement detect lower 1 recovery gain step. Valid range from  0 to 31 */
    uint8_t     powerMeasurementDuration;               /*!< Average power measurement duration = 8*2^powerMeasurementDuration. Valid range from 0 to 31 */
    uint16_t    rx1TddPowerMeasDuration;                /*!< Measurement duration to detect power for specific slice of the gain update counter. */
    uint16_t    rx1TddPowerMeasDelay;                   /*!< Measurement delay to detect power for specific slice of the gain update counter. */
    uint16_t    rx2TddPowerMeasDuration;                /*!< Measurement duration to detect power for specific slice of the gain update counter. */
    uint16_t    rx2TddPowerMeasDelay;                   /*!< Measurement delay to detect power for specific slice of the gain update counter. */
    uint8_t     upper0PowerThresh;                      /*!< AGC upper 0 (overRangeHighPowerThreshold) threshold for power measurement. Valid Range from 0 to 127.*/
    uint8_t     upper1PowerThresh;                      /*!< AGC upper 1 (overRangeLowPowerThreshold)  threshold for power measurement. Valid offset from 0 to 15 */
    uint8_t     powerLogShift;                          /*!< Enable Increase in dynamic range of the power measurement from 40dB to ~60dB. Provides higher accuracy. */

} taliseAgcPower_t;

/**
 * \brief Data structure to hold all AGC configuration settings for initialization
 *  The evaluation software GUI for the product can be used to generate a structure with suggested settings.
 */
typedef struct
{
    uint8_t     agcPeakWaitTime;                    /*!< AGC peak wait time. Valid range is from 0 to 31 */
    uint8_t     agcRx1MaxGainIndex;                 /*!< AGC Rx1 max gain index. Valid range is from 0 to 255 */
    uint8_t     agcRx1MinGainIndex;                 /*!< AGC Rx1 min gain index. Valid range is from 0 to 255 */
    uint8_t     agcRx2MaxGainIndex;                 /*!< AGC Rx2 max gain index. Valid range is from 0 to 255 */
    uint8_t     agcRx2MinGainIndex;                 /*!< AGC Rx2 min gain index. Valid range is from 0 to 255 */
    uint32_t    agcGainUpdateCounter_us;            /*!< AGC gain update time in micro seconds */
    uint8_t     agcRx1AttackDelay;                  /*!< On entering Rx, the Rx1 AGC is kept inactive for a period = agcRx1AttackDelay*1us */
    uint8_t     agcRx2AttackDelay;                  /*!< On entering Rx, the Rx2 AGC is kept inactive for a period = agcRx2AttackDelay*1us */
    uint8_t     agcSlowLoopSettlingDelay;           /*!< On any gain change, the AGC waits for the time (range 0 to 127) specified in AGC clock cycles to allow gain transients to flow through the Rx path before starting any measurements. */
    uint8_t     agcLowThreshPreventGain;            /*!< Prevent gain index from incrementing if peak thresholds are being exceeded */
    uint8_t     agcChangeGainIfThreshHigh;          /*!< Enable immediate gain change if high threshold counter is exceeded. Bit 0 enables ULB high threshold, Bit 1 enables HB2 high threshold */
    uint8_t     agcPeakThreshGainControlMode;       /*!< Enable gain change based only on the signal peak threshold over-ranges. Power based AGC changes are disabled in this mode. */
    uint8_t     agcResetOnRxon;                     /*!< Reset the AGC slow loop state machine to max gain when the Rx Enable is taken low */
    uint8_t     agcEnableSyncPulseForGainCounter;   /*!< Enable the AGC gain update counter to be sync'ed to a time-slot boundary. */
    uint8_t     agcEnableIp3OptimizationThresh;     /*!< (API disables feature, this member is ignored) Enable the two-threshold AGC loop mode.To improve IIP3. Enable=1, Disable=0 (set to 0 for Talise B1 and C0 silicon - this feature is not supported) */
    uint8_t     ip3OverRangeThresh;                 /*!< (API disables feature, this member is ignored) Overload threshold that triggers for a lower peak signal level. Recommended to be set to -17dBFS */
    uint8_t     ip3OverRangeThreshIndex;            /*!< (API disables feature, this member is ignored) Gain index to jump to if current gain causes IP3 overload. Recommended to be set to 246. Valid range 0 to 255 */
    uint8_t     ip3PeakExceededCnt;                 /*!< (API disables feature, this member is ignored) Configures the number of times the ADC IP3 Overrange threshold is triggered within one gain update interval before a gain change is mandated by the gain control loop. */
    uint8_t     agcEnableFastRecoveryLoop;          /*!< Enable multiple time constants in AGC loop for fast attack and fast recovery. */

    taliseAgcPower_t agcPower;
    taliseAgcPeak_t agcPeak;

} taliseAgcCfg_t;

/**
 * \brief Data structure to hold all AGC Dualband configuration.
 * Used along with taliseRxChannels_t structure to setup AGC for Rx1 and/or Rx2
 */
typedef struct
{
    uint8_t agcDualBandEnable;                  /*!< Enable AGC operation for dualband receiver  */
    uint8_t agcRxDualbandExtTableUpperIndex;    /*!< Rx1/2 AGC dual band operation - Indicates the gain table index below which the AGC prioritizes
                                                     decreasing gain through external LNA control over the Front-end gain  */
    uint8_t agcRxDualbandExtTableLowerIndex;    /*!< Rx1/2 AGC dual band operation - Indicates the gain table index above which the AGC prioritizes
                                                     increasing gain through external LNA control over the Front-end gain  */
    uint8_t agcDualbandPwrMargin;               /*!< Margin for comparing total power against power of individual bands. If
                                                     Total power > Upper Band Power + Lower Band Power +margin, the signal contains other components
                                                     than the two bands, and AGC should behave like a single band system. Margin is in 0.5db steps. */
    uint8_t agcDualbandLnaStep;                 /*!< Margin to compare Upper band power versus Lower band power
                                                     (for Upper Band Power > Lower Band Power + margin, and Lower Band Power > Upper Band Power + margin checks).
                                                     The margin compares the powers of the bands to change the LNA of one band so that powers of the bands match.
                                                     Value is in 0.5db resolution  */
    uint8_t agcDualbandHighLnaThreshold;        /*!< High threshold for Upper band or Lower band power above which the LNA index is decreased.
                                                     Value is in 0.5db */
    uint8_t agcDualbandLowLnaThreshold;         /*!< Low threshold for Upper band or Lower band power below which the LNA index is increased.
                                                     Value is in 0.5db */
    uint8_t dualBandGpioEnable;                 /*!< Enable the 3.3V GPIO's that would be used to drive the external LNA's.
                                                     Rx1 : GPIO3.3[1:0] controls Lower band LNA, GPIO3.3[3:2] controls Upper band LNA
                                                     Rx2 : GPIO3.3[5:4] controls Lower band LNA, GPIO3.3[7:6] controls Upper band LNA
                                                     If disabled, user needs to use TALISE_getDualBandLnaControls() to read back the LNA control
                                                     value through the SPI. */
    uint8_t decPowerDdcMeasurementDuration;     /*!< Power measurement duration for measuring the power of the individual bands. This variable has
                                                     a range of 0 to 31. The sampling period is calculated as = 8 x 2^decPowerDdcMeasurementDuration. */
} taliseAgcDualBandCfg_t;

/**
 * \brief Data structure to hold AGC Dualband LNA controls for the external LNA's.
 * Used along with taliseRxChannels_t structure to read back LNA controls for Rx1 or Rx2
 */
typedef struct
{
    uint8_t rxLowerBandLnaControl;         /* The control value for the Rx1/2 Lower band LNA (Values 0-3) */
    uint8_t rxUpperBandLnaControl;         /* The control value for the Rx1/2 Upper band LNA (Values 0-3) */
} taliseDualBandLnaControls_t;

#ifdef __cplusplus
}
#endif

#endif /* TALISE_AGC_TYPES_H_ */
/**
 * \file talise_arm_types.h
 * \brief Contains Talise ARM data types
 *
 * Talise API version: 3.4.0.0
 *
 * Copyright 2015-2017 Analog Devices Inc.
 * Released under the AD9378-AD9379 API license, for more information see the "LICENSE.txt" file in this zip file.
 */

#ifndef TALISE_ARM_TYPES_H_
#define TALISE_ARM_TYPES_H_

#ifdef __cplusplus
extern "C" {
#endif


typedef enum
{
    TALAPI_ARMERR_BOOTUP_TIMEOUT_ERROR, /*!< Timed out waiting for ARM bootup to happen*/
    TALAPI_ARMERR_BOOTUP_IDLE,          /*!< ARM in IDLE mode after bootup*/
    TALAPI_ARMERR_BOOTUP_RADIO_ON,      /*!< ARM in RADIO_ON mode after bootup*/
    TALAPI_ARMERR_BOOTUP_PROFILE_ERROR, /*!< ARM Profile error during bootup*/
    TALAPI_ARMERR_BOOTUP_UNKNOWN_ERROR  /*!< ARM unknown error during bootup*/
} talApiArmErr_t;

typedef enum
{
    TAL_ARM_BUILD_DEBUG,                /*!< ARM binary is Debug Object*/
	TAL_ARM_BUILD_TEST_OBJECT,          /*!< ARM binary is Test Object*/
	TAL_ARM_BUILD_RELEASE               /*!< ARM binary is Release*/
} taliseArmBuildType_t;

typedef struct
{
	uint8_t majorVer;                   /*!< The ARM Major revision*/
	uint8_t minorVer;                   /*!< The ARM Minor revision*/
	uint8_t rcVer;                      /*!< The release candidate version (build number)*/
	taliseArmBuildType_t buildType;        /*!< What type of ARM binary build*/
} taliseArmVersionInfo_t;

#ifdef __cplusplus
}
#endif

#endif /* TALISE_ARM_TYPES_H_ */
/**
 * \file talise_cals_types.h
 * \brief Contains Talise API Calibration data types
 *
 * Talise API version: 3.4.0.0
 *
 * Copyright 2015-2017 Analog Devices Inc.
 * Released under the AD9378-AD9379 API license, for more information see the "LICENSE.txt" file in this zip file.
 */

#ifndef TALISE_CALS_TYPES_H_
#define TALISE_CALS_TYPES_H_

#ifdef __cplusplus
extern "C" {
#endif

typedef enum
{
    TAL_TX_BB_FILTER            = 0x00000001,   /*!< Tx BB filter calibration */
    TAL_ADC_TUNER               = 0x00000002,   /*!< ADC tuner calibration */
    TAL_TIA_3DB_CORNER          = 0x00000004,   /*!< TIA 3dB corner calibration */
    TAL_DC_OFFSET               = 0x00000008,   /*!< DC offset calibration */
    TAL_TX_ATTENUATION_DELAY    = 0x00000010,   /*!< Tx attenuation delay calibration */
    TAL_RX_GAIN_DELAY           = 0x00000020,   /*!< Rx gain delay calibration */
    TAL_FLASH_CAL               = 0x00000040,   /*!< Flash converter comparator calibration */
    TAL_PATH_DELAY              = 0x00000080,   /*!< Path delay equalization calibration */
    TAL_TX_LO_LEAKAGE_INTERNAL  = 0x00000100,   /*!< Internal Tx LO leakage calibration */
    TAL_TX_LO_LEAKAGE_EXTERNAL  = 0x00000200,   /*!< External Tx LO leakage calibration */
    TAL_TX_QEC_INIT             = 0x00000400,   /*!< Tx quadrature error correction calibration */
    TAL_LOOPBACK_RX_LO_DELAY    = 0x00000800,   /*!< Loopback Rx LO delay path calibration */
    TAL_LOOPBACK_RX_RX_QEC_INIT = 0x00001000,   /*!< Loopback Rx quadrature error correction calibration */
    TAL_RX_LO_DELAY             = 0x00002000,   /*!< Rx LO delay path calibration */
    TAL_RX_QEC_INIT             = 0x00004000,   /*!< Rx quadrature error correction calibration */
    TAL_RX_PHASE_CORRECTION     = 0x00008000,   /*!< Rx Phase correction calibration */
    TAL_ORX_LO_DELAY            = 0x00010000,   /*!< ORx LO delay path calibration */
    TAL_ORX_QEC_INIT            = 0x00020000,   /*!< ORx quadrature error correction calibration */
    TAL_TX_DAC                  = 0x00040000,   /*!< Tx DAC passband calibration */
    TAL_ADC_STITCHING           = 0x00080000,   /*!< ADC stitching calibration */
    TAL_FHM_CALS                = 0x00800000    /*!< FHM (Fast Frequency Hopping Mode) Calibrations */
} taliseInitCalibrations_t;

typedef enum
{
    TAL_TRACK_NONE              = 0x00000000,   /*!< Disable all tracking calibrations */
    TAL_TRACK_RX1_QEC           = 0x00000001,   /*!< Rx1 quadrature error correction tracking calibration */
    TAL_TRACK_RX2_QEC           = 0x00000002,   /*!< Rx2 quadrature error correction tracking calibration */
    TAL_TRACK_ORX1_QEC          = 0x00000004,   /*!< ORx1 quadrature error correction tracking calibration */
    TAL_TRACK_ORX2_QEC          = 0x00000008,   /*!< ORx2 quadrature error correction tracking calibration */
    TAL_TRACK_TX1_LOL           = 0x00000010,   /*!< Tx1 LO leakage tracking calibration */
    TAL_TRACK_TX2_LOL           = 0x00000020,   /*!< Tx2 LO leakage tracking calibration */
    TAL_TRACK_TX1_QEC           = 0x00000040,   /*!< Tx1 quadrature error correction tracking calibration */
    TAL_TRACK_TX2_QEC           = 0x00000080,   /*!< Tx2 quadrature error correction tracking calibration */
    TAL_TRACK_RX1_HD2           = 0x00000100,   /*!< Rx1 HD2 error correction tracking calibration */
    TAL_TRACK_RX2_HD2           = 0x00000200,   /*!< Rx2 HD2 error correction tracking calibration */
    TAL_TRACK_ALL               = 0x000003FF    /*!< ENUM specifies all tracking cals */
} taliseTrackingCalibrations_t;

/**
 *  \brief Enum of possible wait events to use with TALISE_waitForEvent()
 */
typedef enum
{
    TAL_CLKPLLCP = 0,               /*!< CLK PLL CP wait event */
    TAL_CLKPLL_LOCK,                /*!< CLK PLL lock wait event */
    TAL_RFPLLCP,                    /*!< RF PLL CP wait event */
    TAL_RFPLL_LOCK,                 /*!< RF PLL lock wait event */
    TAL_AUXPLLCP,                   /*!< AUX PLL CP wait event */
    TAL_AUXPLL_LOCK,                /*!< AUX PLL LOCK wait event */
    TAL_ARMBUSY                     /*!< ARM busy wait event */
} taliseWaitEvent_t;

/**
 *  \brief Enum of possible Rx Digital DC Offset channels
 */
typedef enum
{
    TAL_DC_OFFSET_RX_CHN = 0,
    TAL_DC_OFFSET_ORX_CHN = 1
} taliseDcOffsetChannels_t;

/**
 * \brief Data structure to hold Tx LOL Status
 */
typedef struct
{
    uint32_t errorCode;         /*!< error code from Tx LOL */
    uint32_t percentComplete;   /*!< percent of required data collected for the current cal. Range 0 to 100 */
    uint32_t varianceMetric;    /*!< metric of how well the tracking cal is performing */
    uint32_t iterCount;         /*!< running counter that increments each time the cal runs to completion */
    uint32_t updateCount;       /*!< running counter that increments each time the cal updates the correction/actuator hardware */
} taliseTxLolStatus_t;

/**
 * \brief Data structure to hold Tx QEC Status
 */
typedef struct
{
    uint32_t errorCode;         /*!< error code from Tx QEC */
    uint32_t percentComplete;   /*!< percent of required data collected for the current cal. Range 0 to 100 */
    uint32_t correctionMetric;  /*!< metric of how well the tracking cal is performing */
    uint32_t iterCount;         /*!< running counter that increments each time the cal runs to completion */
    uint32_t updateCount;       /*!< running counter that increments each time the cal updates the correction/actuator hardware */
} taliseTxQecStatus_t;

/**
 * \brief Data structure to hold Rx QEC Status
 */
typedef struct
{
    uint32_t errorCode;         /*!< error code from Rx QEC */
    uint32_t percentComplete;   /*!< percent of required data collected for the current cal. Range 0 to 100 */
    uint32_t selfcheckIrrDb;    /*!<  */
    uint32_t iterCount;         /*!< running counter that increments each time the cal runs to completion */
    uint32_t updateCount;       /*!< running counter that increments each time the cal updates the correction/actuator hardware */
} taliseRxQecStatus_t;

/**
 * \brief Data structure to hold Orx QEC Status
 */
typedef struct
{
    uint32_t errorCode;         /*!< error code from Orx QEC */
    uint32_t percentComplete;   /*!< percent of required data collected for the current cal. Range 0 to 100 */
    uint32_t selfcheckIrrDb;    /*!<  */
    uint32_t iterCount;         /*!< running counter that increments each time the cal runs to completion */
    uint32_t updateCount;       /*!< running counter that increments each time the cal updates the correction/actuator hardware */
} taliseOrxQecStatus_t;

/**
 * \brief Data structure to hold Rx HD2 Status
 */
typedef struct
{
    uint32_t errorCode;         /*!< error code from HD2 */
    uint32_t percentComplete;   /*!< NOT APPLICABLE FOR HD2  Dynamic condition of this cal does not allow for convergence */
    uint32_t confidenceLevel;   /*!< Confidence level that cal has accurately indentified the coefficient required to cancel HD2  */
                                /*!<     0 - No Observation, 1 - 7 indicates increasing confidence level */
    uint32_t iterCount;         /*!< running counter that increments each time the cal runs to completion */
    uint32_t updateCount;       /*!< running counter that increments each time the cal updates the correction/actuator hardware */
} taliseRxHd2Status_t;

/**
 * \brief Data structure to hold Rx HD2 calibration config settings
 *
 * Note: Set posSideBandSel to the side (negative - lower side band or
 * positive - upper side band) that has the desired
 * signal.  Correction will be correcting the 2nd harmonic distortion on the
 * same side of the spectrum.
 */
typedef struct
{
    uint32_t posSideBandSel;     /*!< 1 = Correct HD2 of desired signal on the positive (upper) side of the complex FFT,
                                      0 = correct HD2 in the negative (lower)side of the complex FFT */
} taliseRxHd2Config_t;

#ifdef __cplusplus
}
#endif

#endif /* TALISE_CALS_TYPES_H_ */
/**
 * \file talise_error_types.h
 * \brief Contains Talise data types for API Error messaging
 *
 * Talise API version: 3.4.0.0
 *
 * Copyright 2015-2017 Analog Devices Inc.
 * Released under the AD9378-AD9379 API license, for more information see the "LICENSE.txt" file in this zip file.
 */

#ifndef TALISE_ERROR_TYPES_H_
#define TALISE_ERROR_TYPES_H_

#ifdef __cplusplus
extern "C" {
#endif

#include "talise_arm_macros.h"

/**
 *  \brief Enum of possible sources of error codes.
 */
typedef enum
{
    TAL_ERRSRC_API,     /*!<API Error Src: Error codes defined by taliseErr_t */
    TAL_ERRSRC_ADIHAL,  /*!<ADI HAL Error Src: Error codes defined by adiHalErr_t*/
    TAL_ERRSRC_TALARMCMD,  /*!< TALISE ARM returned error */
    TAL_ERRSRC_TAL_API_GPIO,     /*!< TALISE GPIO returned error */
    TAL_ERRSRC_TALAPIARM,  /*!< TALISE API returned ARM error */
    TAL_ERRSRC_INITCALS,   /*!< TALISE INITCALS returned error */
    TAL_ERRSRC_TAL_API_C0_PCA, /*!< Reserved Error source */
    TAL_ERRSRC_TAL_API_C0_PHMFOVR /*!< Reserved Error source */
} taliseErrSources_t;

/**
 * \brief Enum of unique error codes from the Talise API functions.
 *        Each error condition in the library shall have its own enum value
 *        to ease debug of errors.
 */
typedef enum
{
    TAL_ERR_OK=0,
    TAL_ERR_INV_NULL_INIT_PARAM,
    TAL_ERR_WAITFOREVENT_INV_PARM,
    TAL_ERR_CLKPLL_INV_HSDIV,
    TAL_ERR_SETCLKPLL_INV_VCOINDEX,
    TAL_ERR_SETCLKPLL_INV_NDIV,
    TAL_ERR_SETRFPLL_INV_PLLNAME,
    TAL_ERR_SETRFPLL_INITCALS_INPROGRESS,
    TAL_ERR_INV_SCALEDDEVCLK_PARAM,
    TAL_ERR_SETRFPLL_INV_REFCLK,
    TAL_ERR_SETORXGAIN_INV_ORXPROFILE,
    TAL_ERR_SETORXGAIN_INV_CHANNEL,
    TAL_ERR_SETORXGAIN_INV_ORX1GAIN,
    TAL_ERR_SETORXGAIN_INV_ORX2GAIN,
    TAL_ERR_SETTXATTEN_INV_STEPSIZE_PARM,
    TAL_ERR_SETRX1GAIN_INV_GAIN_PARM,
    TAL_ERR_SETRX2GAIN_INV_GAIN_PARM,
    TAL_ERR_SER_INV_M_PARM,
    TAL_ERR_SER_INV_NP_PARM,
    TAL_ERR_SER_INV_L_PARM,
    TAL_ERR_SER_INV_ORX_L_PARM,
    TAL_ERR_SER_INV_ORX_M_PARM,
    TAL_ERR_SER_INV_ORX_NP_PARM,
    TAL_ERR_SER_INV_ORX_LANEEN_PARM,
    TAL_ERR_SER_INV_LANERATE_PARM,
    TAL_ERR_SER_INV_ORX_LANERATE_PARM,
    TAL_ERR_SER_INV_LANEEN_PARM,
    TAL_ERR_SER_INV_AMP_PARM,
    TAL_ERR_SER_INV_PREEMP_PARM,
    TAL_ERR_SER_INV_LANEPN_PARM,
    TAL_ERR_SER_LANE_CONFLICT_PARM,
    TAL_ERR_SER_INV_TXSER_DIV_PARM,
    TAL_ERR_SER_LANE_RATE_CONFLICT_PARM,
    TAL_ERR_SER_INV_ZIF_TO_RIF_DATA_PARM,
    TAL_ERR_SER_INV_DUALBAND_DATA_PARM,
    TAL_ERR_SER_INV_RXFRAMER_SEL,
    TAL_ERR_SER_INV_ORXFRAMER_SEL,
    TAL_ERR_SER_LANERATE_ZERO,
    TAL_ERR_HS_AND_LANE_RATE_NOT_INTEGER_MULT,
    TAL_ERR_DESES_HS_AND_LANE_RATE_NOT_INTEGER_MULT,
    TAL_ERR_DESES_INV_LANE_RATE,
    TAL_ERR_DESES_INV_LANE_RATE_DIV,
    TAL_ERR_DESER_INV_M_PARM,
    TAL_ERR_DESER_INV_NP_PARM,
    TAL_ERR_DESER_INV_L_PARM,
    TAL_ERR_DESER_INV_LANERATE_PARM,
    TAL_ERR_DESER_INV_LANEEN_PARM,
    TAL_ERR_DESER_INV_EQ_PARM,
    TAL_ERR_DESER_INV_LANEPN_PARM,
    TAL_ERR_DESER_LANECONFLICT_PARM,
    TAL_ERR_DESER_M_CONFLICT,
    TAL_ERR_DESER_INV_DEFAB_M,
    TAL_ERR_DESER_NP_CONFLICT,
    TAL_ERR_DESER_INV_DEFRAMERSEL,
    TAL_ERR_DESER_TXPROFILE_INV,
    TAL_ERR_FRAMER_INV_M_PARM,
    TAL_ERR_FRAMER_INV_NP_PARM,
    TAL_ERR_FRAMER_INV_S_PARM,
    TAL_ERR_FRAMER_INV_BANKID_PARM,
    TAL_ERR_FRAMER_INV_LANEID_PARM,
    TAL_ERR_FRAMER_INV_SYNCBIN_PARM,
    TAL_ERR_FRAMER_INV_LMFC_OFFSET_PARAM,
    TAL_ERR_FRAMER_INV_DUALBAND_DATA_PARM,
    TAL_ERR_DEFRAMER_INV_BANKID,
    TAL_ERR_ERR_DEFRAMER_INV_LANEID,
    TAL_ERR_DEFRAMER_INV_LMFC_OFFSET,
    TAL_ERR_DEFRAMER_INV_DEFSEL,
    TAL_ERR_DEFRAMER_INV_TXPROFILE,
    TAL_ERR_DEFRAMER_INV_LANESEN,
    TAL_ERR_DEFRAMER_INV_L,
    TAL_ERR_DEFRAMER_INV_M,
    TAL_ERR_DEFRAMER_INV_NP,
    TAL_ERR_DEFRAMER_INV_F,
    TAL_ERR_DEFRAMER_INV_K,
    TAL_ERR_DEFRAMER_INV_FK,
    TAL_ERR_DEFRAMER_INV_PCLK,
    TAL_ERR_DEFRAMER_INV_PCLKDIV,
    TAL_ERR_RSTDEFRAMER_INV_DEFSEL,
    TAL_ERR_RSTFRAMER_INV_FRAMERSEL,
    TAL_ERR_SETDFRMIRQMASK_INV_DEFRAMERSEL_PARAM,
    TAL_ERR_DEFSTATUS_INV_DEFRAMERSEL_PARAM,
    TAL_ERR_DEFSTATUS_NULL_DEFRAMERSTATUS_PARAM,
    TAL_ERR_GETDFRMIRQMASK_NULL_IRQMASK_PARAM,
    TAL_ERR_GETDFRMIRQMASK_INV_DEFRAMERSELECT_PARAM,
    TAL_ERR_CLRDFRMIRQ_INV_DEFRAMERSEL_PARAM,
    TAL_ERR_GETDFRMIRQSRC_INV_DEFRAMERSEL_PARAM,
    TAL_ERR_GETDFRMIRQSRC_NULL_STATUS_PARAM,
    TAL_ERR_ENDEFSYSREF_INV_DEFRAMERSEL_PARAM,
    TAL_ERR_ENFRAMERSYSREF_INV_FRAMERSEL_PARAM,
    TAL_ERR_FRAMER_INV_TESTDATA_SOURCE_PARAM,
    TAL_ERR_FRAMER_INV_INJECTPOINT_PARAM,
    TAL_ERR_FRAMERSTATUS_INV_FRAMERSEL_PARAM,
    TAL_ERR_FRAMERSTATUS_NULL_FRAMERSTATUS_PARAM,
    TAL_ERR_EN_DEFRAMER_PRBS_INV_PARAM,
    TAL_ERR_READDFRMPRBS_INV_DEFSEL_PARAM,
    TAL_ERR_READDFRMPRBS_NULL_PARAM,
    TAL_ERR_INITARM_INV_ARMCLK_PARAM,
    TAL_ERR_LOADHEX_INVALID_CHKSUM,
    TAL_ERR_LOADBIN_INVALID_BYTECOUNT,
    TAL_ERR_READARMMEM_INV_ADDR_PARM,
    TAL_ERR_WRITEARMMEM_INV_ADDR_PARM,
    TAL_ERR_ARMCMD_INV_OPCODE_PARM,
    TAL_ERR_ARMCMD_INV_NUMBYTES_PARM,
    TAL_ERR_ARMCMDSTATUS_INV_OPCODE_PARM,
    TAL_ERR_JESD204B_ILAS_MISMATCH_NULLPARAM,
    TAL_ERR_JESD204B_ILAS_MISMATCH_NO_ACTIVE_LINK,
    TAL_ERR_JESD204B_ILAS_MISMATCH_SYNC_NOT_DETECTED,
    TAL_ERR_JESD204B_ILAS_MISMATCH_INVALID_DEFRAMER,
    TAL_ERR_TALFINDDFRMRLANECNTERROR_INV_DEFRAMERSEL_PARAM,
    TAL_ERR_TALFINDDFRMRLANECNTERROR_NULL_PARAM,
    TAL_ERR_TALFINDDFRMRLANEERROR_NULL_PARAM,
    TAL_ERR_RXGAINTABLE_INV_CHANNEL,
    TAL_ERR_RXGAINTABLE_INV_PROFILE,
    TAL_ERR_RXGAINTABLE_INV_GAIN_INDEX_RANGE,
    TAL_ERR_ORXGAINTABLE_INV_CHANNEL,
    TAL_ERR_ORXGAINTABLE_INV_PROFILE,
    TAL_ERR_ORXGAINTABLE_INV_GAIN_INDEX_RANGE,
    TAL_ERR_RXFRAMER_INV_FK_PARAM,
    TAL_ERR_RXFRAMER_INV_L_PARAM,
    TAL_ERR_INV_RX_GAIN_MODE_PARM,
    TAL_ERR_UNSUPPORTED_RX_GAIN_MODE_PARM,
    TAL_ERR_INV_AGC_RX_STRUCT_INIT,
    TAL_ERR_INV_AGC_PWR_STRUCT_INIT,
    TAL_ERR_INV_AGC_PWR_LWR0THRSH_PARAM,
    TAL_ERR_INV_AGC_PWR_LWR1THRSH_PARAM,
    TAL_ERR_INV_AGC_PWR_LWR0PWRGAINSTEP_PARAM,
    TAL_ERR_INV_AGC_PWR_LWR1PWRGAINSTEP_PARAM,
    TAL_ERR_INV_AGC_PWR_MSR_DURATION_PARAM,
    TAL_ERR_INV_AGC_PWR_IP3RANGE_PARAM,
    TAL_ERR_INV_AGC_PWR_UPPWR0THRSH_PARAM,
    TAL_ERR_INV_AGC_PWR_UPPWR1THRSH_PARAM,
    TAL_ERR_INV_AGC_PWR_LOGSHIFT_PARAM,
    TAL_ERR_INV_AGC_PKK_STRUCT_INIT,
    TAL_ERR_INV_AGC_PKK_HIGHTHRSH_PARAM,
    TAL_ERR_INV_AGC_PKK_LOWGAINMODEHIGHTHRSH_PARAM,
    TAL_ERR_INV_AGC_PKK_LOWGAINHIGHTHRSH_PARAM,
    TAL_ERR_INV_AGC_PKK_LOWGAINTHRSH_PARAM,
    TAL_ERR_INV_AGC_PKK_GAINSTEPATTACK_PARAM,
    TAL_ERR_INV_AGC_PKK_GAINSTEPRECOVERY_PARAM,
    TAL_ERR_INV_AGC_PKK_HB2OVRLD_PARAM,
    TAL_ERR_INV_AGC_PKK_HB2OVRLDDURATION_PARAM,
    TAL_ERR_INV_AGC_PKK_HB2OVRLDTHRSHCNT_PARAM,
    TAL_ERR_INV_AGC_PKK_HB2GAINSTEPRECOVERY_PARAM,
    TAL_ERR_INV_AGC_PKK_HB2GAINSTEP0RECOVERY_PARAM,
    TAL_ERR_INV_AGC_PKK_HB2GAINSTEP1RECOVERY_PARAM,
    TAL_ERR_INV_AGC_PKK_HB2GAINSTEPATTACK_PARAM,
    TAL_ERR_INV_AGC_PKK_HB2OVRLDPWRMODE_PARAM,
    TAL_ERR_INV_AGC_PKK_HB2OVRLDSEL_PARAM,
    TAL_ERR_INV_AGC_PKK_HB2THRSHCFG_PARAM,
    TAL_ERR_INV_AGC_RX_APD_THRESH_DIFF_VS_ATTACK_GAIN_STEP,
    TAL_ERR_INV_AGC_RX_PEAK_WAIT_TIME_PARM,
    TAL_ERR_INV_AGC_RX_MIN_MAX_GAIN_PARM,
    TAL_ERR_INV_AGC_RX_MIN_GAIN_GRT_THAN_MAX_GAIN_PARM,
    TAL_ERR_INV_AGC_RX_GAIN_UPDATE_TIME_PARM,
    TAL_ERR_INV_AGC_RX1ATTACKDELAY_PARAM,
    TAL_ERR_INV_AGC_RX2ATTACKDELAY_PARAM,
    TAL_ERR_INV_AGC_RX_LOWTHRSHPREVENTGAIN_PARM,
    TAL_ERR_INV_AGC_RX_CHANGEGAINTHRSHHIGH_PARM,
    TAL_ERR_INV_AGC_RX_RESETONRXON_PARM,
    TAL_ERR_INV_AGC_RX_ENSYNCHPULSECAINCNTR_PARM,
    TAL_ERR_INV_AGC_RX_ENIP3OPTTHRSH_PARM,
    TAL_ERR_INV_AGC_RX_ENFASTRECOVERYLOOP_PARM,
    TAL_ERR_INV_AGC_SLOWLOOPDELAY_PARAM,
    TAL_ERR_INV_MINAGCSLOWLOOPDELAY_PARAM,
    TAL_ERR_INV_AGC_CLK_DIV_RATIO_PARM,
    TAL_ERR_INV_AGC_CLK_PARM,
    TAL_ERR_INV_AGC_CLK_RATIO,
    TAL_ERR_INV_AGC_RX_GAIN_UNDERRANGE_UPDATE_TIME_PARM,
    TAL_ERR_INV_AGC_RX_GAIN_UNDERRANGE_MID_INTERVAL_PARM,
    TAL_ERR_INV_AGC_RX_GAIN_UNDERRANGE_HIGH_INTERVAL_PARM,
    TAL_ERR_WAITFOREVENT_TIMEDOUT_CLKPLLCP,
    TAL_ERR_WAITFOREVENT_TIMEDOUT_CLKPLL_LOCK,
    TAL_ERR_WAITFOREVENT_TIMEDOUT_RFPLLCP,
    TAL_ERR_WAITFOREVENT_TIMEDOUT_RFPLL_LOCK,
    TAL_ERR_WAITFOREVENT_TIMEDOUT_AUXPLLCP,
    TAL_ERR_WAITFOREVENT_TIMEDOUT_AUXPLL_LOCK,
    TAL_ERR_WAITFOREVENT_TIMEDOUT_ARMBUSY,
    TAL_ERR_TIMEDOUT_ARMMAILBOXBUSY,
    TAL_ERR_EN_TRACKING_CALS_ARMSTATE_ERROR,
    TAL_ERR_GETPENDINGTRACKINGCALS_NULL_PARAM,
    TAL_ERR_TRACKINGCAL_OUTOFRANGE_PARAM,
    TAL_ERR_PAUSETRACKINGCAL_INV_PARAM,
    TAL_ERR_GETPAUSECALSTATE_NULL_PARAM,
    TAL_ERR_SET_ARMGPIO_PINS_GPIO_IN_USE,
    TAL_ERR_SET_ARMGPIO_PINS_INV_SIGNALID,
    TAL_ERR_SET_ARMGPIO_PINS_INV_GPIOPIN,
    TAL_ERR_SET_RXDATAFRMT_NULL_PARAM,
    TAL_ERR_SET_RXDATAFRMT_FORMATSELECT_INVPARAM,
    TAL_ERR_SET_RXDATAFRMT_TEMPCOMP_INVPARAM,
    TAL_ERR_SET_RXDATAFRMT_ROUNDMODE_INVPARAM,
    TAL_ERR_SET_RXDATAFRMT_FPDATAFRMT_INVPARAM,
    TAL_ERR_SET_RXDATAFRMT_FPENCNAN_INVPARAM,
    TAL_ERR_SET_RXDATAFRMT_FPEXPBITS_INVPARAM,
    TAL_ERR_SET_RXDATAFRMT_FPHIDELEADINGONE_INVPARAM,
    TAL_ERR_SET_RXDATAFRMT_FPRX1ATTEN_INVPARAM,
    TAL_ERR_SET_RXDATAFRMT_FPRX2ATTEN_INVPARAM,
    TAL_ERR_SET_RXDATAFRMT_INTEMBEDDEDBITS_INVPARAM,
    TAL_ERR_SET_RXDATAFRMT_INTSAMPLERESOLUTION_INVPARAM,
    TAL_ERR_SET_RXDATAFRMT_PINSTEPSIZE_INVPARAM,
    TAL_ERR_SET_RXDATAFRMT_RX1GPIOSELECT_INVPARAM,
    TAL_ERR_SET_RXDATAFRMT_RX2GPIOSELECT_INVPARAM,
    TAL_ERR_SET_RXDATAFRMT_RXCHAN_DISABLED,
    TAL_ERR_SET_RXDATAFRMT_EXTERNALLNAGAIN_INVPARAM,
    TAL_ERR_SET_RXDATAFRMT_RX1GPIO_INUSE,
    TAL_ERR_SET_RXDATAFRMT_RX2GPIO_INUSE,
    TAL_ERR_SET_RXDATAFRMT_DATARES_INVPARAM,
    TAL_ERR_SET_RXDATAFRMT_EXTSLICER_RX1GPIO_INVPARAM,
    TAL_ERR_SET_RXDATAFRMT_EXTSLICER_RX2GPIO_INVPARAM,
    TAL_ERR_GET_DATAFORMAT_NULL_PARAM,
    TAL_ERR_GET_SLICERPOS_NULL_PARAM,
    TAL_ERR_INIT_NULLPARAM,
    TAL_ERR_INIT_INV_DEVCLK,
    TAL_ERR_GETRADIOSTATE_NULL_PARAM,
    TAL_ERR_WAIT_INITCALS_ARMERROR,
    TAL_ERR_WAIT_INITCALS_NULL_PARAM,
    TAL_ERR_CHECK_PLL_LOCK_NULL_PARM,
    TAL_ERR_READGPIOSPI_NULL_PARM,
    TAL_ERR_READGPIO3V3SPI_NULL_PARM,
    TAL_ERR_GET_TXFILTEROVRG_NULL_PARM,
    TAL_ERR_PROGRAM_RXGAIN_TABLE_NULL_PARM,
    TAL_ERR_PROGRAM_ORXGAIN_TABLE_NULL_PARM,
    TAL_ERR_PROGRAMFIR_NULL_PARM,
    TAL_ERR_PROGRAMFIR_COEFS_NULL,
    TAL_ERR_READ_DEFRAMERSTATUS_NULL_PARAM,
    TAL_ERR_READ_DEFRAMERPRBS_NULL_PARAM,
    TAL_ERR_ARMCMDSTATUS_NULL_PARM,
    TAL_ERR_PROGRAMFIR_INV_FIRNAME_PARM,
    TAL_ERR_RXFIR_INV_GAIN_PARM,
    TAL_ERR_PROGRAMFIR_INV_NUMTAPS_PARM,
    TALISE_ERR_TXFIR_INV_NUMTAPS_PARM,
    TALISE_ERR_TXFIR_INV_NUMROWS,
    TALISE_ERR_TXFIR_TAPSEXCEEDED,
    TALISE_ERR_RXFIR_INV_DDC,
    TALISE_ERR_RXFIR_INV_NUMTAPS_PARM,
    TALISE_ERR_RXFIR_INV_NUMROWS,
    TALISE_ERR_RXFIR_TAPSEXCEEDED,
    TALISE_ERR_ORXFIR_INV_DDC,
    TALISE_ERR_ORXFIR_INV_NUMTAPS_PARM,
    TALISE_ERR_ORXFIR_INV_NUMROWS,
    TALISE_ERR_ORXFIR_TAPSEXCEEDED,
    TAL_ERR_WAITARMCMDSTATUS_INV_OPCODE,
    TAL_ERR_WAITARMCMDSTATUS_TIMEOUT,
    TAL_ERR_READARMCMDSTATUS_NULL_PARM,
    TAL_ERR_LOADBIN_NULL_PARAM,
    TAL_ERR_GETARMVER_NULL_PARM,
    TAL_ERR_GETARMVER_V2_NULL_PARM,
    TAL_ERR_GETARMVER_V2_INVALID_ARM_NOT_LOADED,
    TAL_ERR_READEVENTSTATUS_INV_PARM,
    TAL_ERR_FRAMER_INV_FRAMERSEL_PARAM,
    TAL_ERR_FRAMER_ERRINJECT_INV_FRAMERSEL_PARAM,
    TAL_ERR_CHECKPLLLOCK_NULL_PARM,
    TAL_ERR_FRAMER_INV_FRAMERSEL_PARM,
    TAL_ERR_SETTXATTEN_INV_TXCHANNEL,
    TAL_ERR_SETTXATTEN_INV_PARM,
    TAL_ERR_RXFRAMER_INV_OUTPUT_RATE,
    TAL_ERR_RXFRAMER_INV_PCLKFREQ,
    TAL_ERR_BBIC_INV_CHN,
    TAL_ERR_INITCALS_INPROGRESS ,
    TAL_ERR_INV_GP_INT_MASK_PARM,
    TAL_ERR_GP_INT_STATUS_NULL_PARAM,
    TAL_ERR_INV_DAC_SAMP_XBAR_CHANNEL_SEL,
    TAL_ERR_INV_ADC_SAMP_XBAR_FRAMER_SEL,
    TAL_ERR_INV_ADC_SAMP_XBAR_SELECT_PARAM,
    TAL_ERR_INV_DAC_SAMP_XBAR_SELECT_PARAM,
    TAL_ERR_GETRFPLL_INV_PLLNAME,
    TAL_ERR_GET_PLLFREQ_INV_REFCLKDIV,
    TAL_ERR_GET_PLLFREQ_INV_HSDIV,
    TAL_ERR_GETRFPLL_NULLPARAM,
    TAL_ERR_FRAMER_A_AND_B_INV_M_PARM,
    TAL_ERR_SETRXGAIN_RXPROFILE_INVALID,
    TAL_ERR_SETRXGAIN_INV_CHANNEL,
    TAL_ERR_INIT_CALS_COMPLETED_NULL_PTR,
    TAL_ERR_CHKINITCALS_NULL_PTR,
    TAL_ERR_INIT_CALS_LASTRUN_NULL_PTR,
    TAL_ERR_GETENABLED_TRACK_CALS_NULL_PTR,
    TAL_ERR_INIT_CALS_MIN_NULL_PTR,
    TAL_ERR_INIT_ERR_CAL_NULL_PTR,
    TAL_ERR_INIT_ERR_CODE_NULL_PTR,
    TAL_ERR_READARMCFG_ARMERRFLAG,
    TAL_ERR_GETRXGAIN_INV_RXPROFILE,
    TAL_ERR_GETRXGAIN_INV_CHANNEL,
    TAL_ERR_GETRXGAIN_GAIN_RANGE_EXCEEDED,
    TAL_ERR_GETOBSRXGAIN_INV_ORXPROFILE,
    TAL_ERR_GETOBSRXGAIN_INV_CHANNEL,
    TAL_ERR_GETOBSRXGAIN_GAIN_RANGE_EXCEEDED,
    TAL_ERR_SETUPDUALBANDRXAGC_GAIN_RANGE_MISMATCH,
    TAL_ERR_SETUPDUALBANDRXAGC_GAIN_OUT_OF_RANGE,
    TAL_ERR_VERIFYBIN_CHECKSUM_TIMEOUT,
    TAL_ERR_ARMCMDSTATUS_ARMERROR,
    TAL_ERR_VERRXPFILE_INV_IQRATE,
    TAL_ERR_VERRXPFILE_INV_RFBW,
    TAL_ERR_VERRXPFILE_INV_RHB1,
    TAL_ERR_VERRXPFILE_INV_DEC5,
    TAL_ERR_VERRXPFILE_INV_FIR,
    TAL_ERR_VERRXPFILE_INV_COEF,
    TAL_ERR_VERRXPFILE_INV_DDC,
    TAL_ERR_VERORXPFILE_INV_IQRATE,
    TAL_ERR_VERORXPFILE_INV_RFBW,
    TAL_ERR_VERORXPFILE_INV_RHB1,
    TAL_ERR_VERORXPFILE_INV_DEC5,
    TAL_ERR_VERORXPFILE_INV_FIR,
    TAL_ERR_VERORXPFILE_INV_COEF,
    TAL_ERR_VERORXPFILE_INV_DDC,
    TAL_ERR_VERTXPFILE_INV_DISONPLLUNLOCK,
    TAL_ERR_VERTXPFILE_INV_IQRATE,
    TAL_ERR_VERTXPFILE_INV_RFBW,
    TAL_ERR_VERTXPFILE_INV_THB1,
    TAL_ERR_VERTXPFILE_INV_THB2,
    TAL_ERR_VERTXPFILE_INV_THB3,
    TAL_ERR_VERTXPFILE_INV_INT5,
    TAL_ERR_VERTXPFILE_INV_HBMUTEX,
    TAL_ERR_VERTXPFILE_INV_FIRIPL,
    TAL_ERR_VERTXPFILE_INV_COEF,
    TAL_ERR_VERTXPFILE_INV_DACDIV,
    TAL_ERR_VERPFILE_INV_RFPLLMCSMODE,
    TAL_ERR_VERPFILE_TXHSCLK,
    TAL_ERR_VERPFILE_RXHSCLK,
    TAL_ERR_VERPFILE_ORXHSCLK,
    TAL_ERR_SETSPI_INV_CMOS_DRV_STR,
    TAL_ERR_SETCLKPLL_INV_TXATTENDIV,
    TAL_ERR_SETTXTOORXMAP_INV_ORX1_MAP,
    TAL_ERR_SETTXTOORXMAP_INV_ORX2_MAP,
    TAL_ERR_GETRXTXENABLE_NULLPARAM,
    TAL_ERR_SETRXTXENABLE_INVCHANNEL,
    TAL_ERR_GETTXATTEN_NULL_PARM,
    TAL_ERR_GETTXATTEN_INV_TXCHANNEL,
    TAL_ERR_INV_RADIO_CTL_MASK_PARM,
    TAL_ERR_GETPINMODE_NULLPARAM,
    TAL_ERR_SET_ARMGPIO_NULLPARAM,
    TAL_ERR_GETTEMPERATURE_NULLPARAM,
    TAL_ERR_GETTXLOLSTATUS_NULL_PARAM,
    TAL_ERR_GETTXLOLSTATUS_INV_CHANNEL_PARM,
    TAL_ERR_GETTXQECSTATUS_NULL_PARAM,
    TAL_ERR_GETTXQECSTATUS_INV_CHANNEL_PARM,
    TAL_ERR_GETRXQECSTATUS_NULL_PARAM,
    TAL_ERR_GETRXQECSTATUS_INV_CHANNEL_PARM,
    TAL_ERR_GETORXQECSTATUS_NULL_PARAM,
    TAL_ERR_GETORXQECSTATUS_INV_CHANNEL_PARM,
    TAL_ERR_GETRXHD2STATUS_NULL_PARAM,
    TAL_ERR_GETRXHD2STATUS_INV_CHANNEL_PARM,
    TAL_ERR_VERIFYSPI_READ_LOW_ADDR_ERROR,
    TAL_ERR_VERIFYSPI_WRITE_LOW_ADDR_ERROR,
    TAL_ERR_VERIFYSPI_READ_HIGH_ADDR_ERROR,
    TAL_ERR_VERIFYSPI_WRITE_HIGH_ADDR_ERROR,
    TAL_ERR_GETAPIVERSION_NULLPARAM,
    TAL_ERR_INV_DAC_FULLSCALE_PARM,
    TAL_ERR_RESET_TXLOL_INV_CHANNEL_PARM,
    TAL_ERR_RESET_TXLOL_ARMSTATE_ERROR,
    TAL_ERR_SETHD2CFG_NULL_PARAM,
    TAL_ERR_SETHD2CFG_ARMSTATE_ERROR,
    TAL_ERR_GETHD2CFG_NULL_PARAM,
    TAL_ERR_GETHD2CFG_ARMSTATE_ERROR,
    TAL_ERR_SET_SPI2_ENABLE_INVALID_TX_ATTEN_SEL,
    TAL_ERR_SET_SPI2_ENABLE_GPIO_IN_USE,
    TAL_ERR_SETRXMGCPINCTRL_INV_RX1_INC_PIN,
    TAL_ERR_SETRXMGCPINCTRL_INV_RX1_DEC_PIN,
    TAL_ERR_SETRXMGCPINCTRL_INV_RX2_INC_PIN,
    TAL_ERR_SETRXMGCPINCTRL_INV_RX2_DEC_PIN,
    TAL_ERR_SETRXMGCPINCTRL_INV_CHANNEL,
    TAL_ERR_SETRXMGCPINCTRL_INV_INC_STEP,
    TAL_ERR_SETRXMGCPINCTRL_INV_DEC_STEP,
    TAL_ERR_SETRXMGCPINCTRL_RX1_GPIO_IN_USE,
    TAL_ERR_SETRXMGCPINCTRL_RX2_GPIO_IN_USE,
    TAL_ERR_GETRXMGCPINCTRL_INV_CHANNEL,
    TAL_ERR_GETRXMGCPINCTRL_NULL_PARAM,
    TAL_ERR_SETRFPLL_LOOPFILTER_INV_LOOPBANDWIDTH,
    TAL_ERR_SETRFPLL_LOOPFILTER_INV_STABILITY,
    TAL_ERR_SETRFPLL_LOOPFILTER_INV_PLLSEL,
    TAL_ERR_GETRFPLL_LOOPFILTER_NULLPARAM,
    TAL_ERR_GETRFPLL_LOOPFILTER_INV_PLLSEL,
    TAL_ERR_GETDEVICEREV_NULLPARAM,
    TAL_ERR_GETPRODUCTID_NULLPARAM,
    TAL_ERR_ENABLETXNCO_INV_PROFILE,
    TAL_ERR_ENABLETXNCO_NULL_PARM,
    TAL_ERR_ENABLETXNCO_INV_TX1_FREQ,
    TAL_ERR_ENABLETXNCO_INV_TX2_FREQ,
    TAL_ERR_SETTXATTENCTRLPIN_NULL_PARAM,
    TAL_ERR_SETTXATTENCTRLPIN_TX1_GPIO_IN_USE,
    TAL_ERR_SETTXATTENCTRLPIN_TX2_GPIO_IN_USE,
    TAL_ERR_SETTXATTENCTRLPIN_INV_PARM,
    TAL_ERR_SETTXATTENCTRLPIN_INV_TX1_INC_PIN,
    TAL_ERR_SETTXATTENCTRLPIN_INV_TX1_DEC_PIN,
    TAL_ERR_SETTXATTENCTRLPIN_INV_TX2_INC_PIN,
    TAL_ERR_SETTXATTENCTRLPIN_INV_TX2_DEC_PIN,
    TAL_ERR_SETTXATTENCTRLPIN_INV_CHANNEL,
    TAL_ERR_GETTXATTENCTRLPIN_INV_CHANNEL,
    TAL_ERR_GETTXATTENCTRLPIN_NULL_PARAM,
    TAL_ERR_SETUPDUALBANDRX1AGC_GPIO3P3_IN_USE,
    TAL_ERR_SETUPDUALBANDRX2AGC_GPIO3P3_IN_USE,
    TAL_ERR_SETUPDUALBANDRXAGC_INV_CHANNEL,
    TAL_ERR_SETUPDUALBANDRXAGC_NULL_PARAM,
    TAL_ERR_SETUPDUALBANDRXAGC_INV_PWRMARGIN,
    TAL_ERR_SETUPDUALBANDRXAGC_INV_DECPWR,
    TAL_ERR_GETDUALBANDLNA_INV_CHANNEL,
    TAL_ERR_GETDUALBANDLNA_NULL_PARAM,
    TAL_ERR_INITIALIZE_DDC_INV_TOTAL_M_2OR4,
    TAL_ERR_INITIALIZE_DDC_INV_TOTAL_M_4OR8,
    TAL_ERR_INITIALIZE_DDC_NULL_PARAM,
    TAL_ERR_RXNCOFTW_INVNCO,
    TAL_ERR_INITIALIZE_DDC_INV_RXDDCMODE,
    TAL_ERR_INITIALIZE_DDC_INV_DEC_AT_PFIR,
    TAL_ERR_SETDUALBANDSETTINGS_INV_CENTER_FREQ,
    TAL_ERR_SETDUALBANDSETTINGS_INV_BAND_SEP,
    TAL_ERR_SETDUALBANDSETTINGS_INV_IN_UPPER_FREQ,
    TAL_ERR_SETDUALBANDSETTINGS_INV_IN_LOWER_FREQ,
    TAL_ERR_SETDUALBANDSETTINGS_INV_OUT_UPPER_FREQ,
    TAL_ERR_SETDUALBANDSETTINGS_INV_OUT_LOWER_FREQ,
    TAL_ERR_SETDUALBANDSETTINGS_OUT_OVERLAP,
    TAL_ERR_SETDUALBANDSETTINGS_FTW_OVRG,
    TAL_ERR_DUALBAND_LNA_TABLE_INV_PROFILE,
    TAL_ERR_DUALBAND_LNA_TABLE_INV_INDEX,
    TAL_ERR_DUALBAND_LNA_TABLE_INV_CHANNEL,
    TAL_ERR_DUALBAND_LNA_TABLE_NULL_PARM,
    TAL_ERR_SETUPNCOSHIFTER_INV_PFIR_CORNER,
    TAL_ERR_SETUPNCOSHIFTER_INV_DDCHB_CORNER,
    TAL_ERR_SETUPNCOSHIFTER_INV_NCO2SHIFT,
    TAL_ERR_SETUPNCOSHIFTER_FTW_OVRG,
    TAL_ERR_INV_DEFA_SLEWRATE,
    TAL_ERR_INV_DEFB_SLEWRATE,
    TAL_ERR_GETTXSAMPLEPWR_NULL_PARAM,
    TAL_ERR_GETTXSAMPLEPWR_INV_TXREADCHAN,
    TAL_ERR_SETPAPRO_NULL_PARAM,
    TAL_ERR_SETPAPRO_INV_AVGDURATION,
    TAL_ERR_SETPAPROT_INV_PEAKCNT,
    TAL_ERR_SETPAPROT_INV_TXATTENSTEP,
    TAL_ERR_SETPAPROT_INV_TX1THRESH,
    TAL_ERR_SETPAPROT_INV_TX2THRESH,
    TAL_ERR_SETPAPROT_INV_TX1PEAKTHRESH,
    TAL_ERR_SETPAPROT_INV_TX2PEAKTHRESH,
    TAL_ERR_GETPAERRFLAGS_NULL_PARAM,
    TAL_ERR_GETPAPRO_NULL_PARAM,
    TAL_ERR_DAC_FULLSCALE_INVARMSTATE,
    TAL_ERR_DEFSTATUS_INV_COUNTERERRTHRESHOLD_PARAM,
    TAL_ERR_RFPLLFREQ_TX_OUT_OF_RANGE,
    TAL_ERR_RFPLLFREQ_RX_OUT_OF_RANGE,
    TAL_ERR_RFPLLFREQ_ORX_OUT_OF_RANGE,
    TAL_ERR_READEVENTSTATUS_NULL_PARM,
    TAL_ERR_INV_SIREV,
    TAL_ERR_REGISTER_ERRORMSG_C0,
    TAL_ERR_SETEXTWORDCTRLGPIO_INV_CHANNEL,
    TAL_ERR_SETEXTWORDCTRLGPIO_UNINITIALIZED_RX1,
    TAL_ERR_SETEXTWORDCTRLGPIO_UNINITIALIZED_RX2,
    TAL_ERR_SETEXTWORDCTRLGPIO_GPIO_IN_USE_RX1,
    TAL_ERR_SETEXTWORDCTRLGPIO_GPIO_IN_USE_RX2,
    TAL_ERR_FRAMERSYSREFTOGGLE_INV_FRAMERSEL_PARAM,
    TAL_ERR_SETORXLOSRC_INVALIDPARAM,
    TAL_ERR_GETORXLOSRC_NULLPARAM,
    TAL_ERR_SETORXLOSRC_TIMEDOUT_ARMMAILBOXBUSY,
    TAL_ERR_SETORXLOCFG_NULL_PARAM,
    TAL_ERR_SETORXLOCFG_INVALIDPARAM,
    TAL_ERR_SETORXLOCFG_INVALID_ARMSTATE,
    TAL_ERR_SETORXLOCFG_GPIOUSED,
    TAL_ERR_GETORXLOCFG_NULL_PARAM,
    TAL_ERR_GETORXLOCFG_INVALID_ARMSTATE,
	TAL_ERR_SETFHMCONFIG_NULL_PARAM,
	TAL_ERR_SETFHMCONFIG_INV_FHMGPIOPIN,
	TAL_ERR_SETFHMCONFIG_INV_FHMCONFIG_FHM_MIN_FREQ,
	TAL_ERR_SETFHMCONFIG_INV_FHMCONFIG_FHM_MAX_FREQ,
	TAL_ERR_SETFHMCONFIG_FHMGPIOPIN_IN_USE,
	TAL_ERR_GETFHMCONFIG_NULL_PARAM,
	TAL_ERR_SETFHMMODE_NULL_PARAM,
	TAL_ERR_SETFHMMODE_INV_FHM_INIT_FREQ,
	TAL_ERR_SETFHMMODE_INV_FHM_TRIGGER_MODE,
	TAL_ERR_SETFHMMODE_INV_FHM_EXIT_MODE,
	TAL_ERR_GETFHMMODE_NULL_PARAM,
	TAL_ERR_SETFHMHOP_INV_FHM_FREQ,
	TAL_ERR_GETFHMSTS_NULL_PARAM,
    TAL_ERR_SETDCMSHIFT_INV_CH_PARAM,
    TAL_ERR_SETDCMSHIFT_INV_MSHIFT_PARAM,
    TAL_ERR_GETDCMSHIFT_INV_CH_PARAM,
    TAL_ERR_GETDCMSHIFT_NULL_MSHIFT_PARAM,
    TAL_ERR_SETEXTLOOUT_INV_DIV_PARAM,
    TAL_ERR_SETEXTLOOUT_LO_IN_ENABLED,
    TAL_ERR_GETEXTLOOUT_NULL_PARAM,
    TAL_ERR_NUMBER_OF_ERRORS /* Keep this ENUM last as a reference to the total number of error enum values */
} taliseErr_t;

/**
 *  \brief Private Enum to list of available error handlers
 */
typedef enum
{
    TAL_ERRHDL_HAL_WAIT, /*!<API Error handler for HAL wait/delay function errors */
    TAL_ERRHDL_HAL_LOG,  /*!<API Error handler for HAL log function error */
    TAL_ERRHDL_HAL_SPI,  /*!<API Error handler for HAL SPI function errors */
    TAL_ERRHDL_HAL_GPIO, /*!<API Error handler for HAL GPIO function errors */
    TAL_ERRHDL_INVALID_PARAM, /*!<API Error handler invalid parameter errors */
    TAL_ERRHDL_API_FAIL,  /*!<API Error handler API functional errors */
    TAL_ERRHDL_APIARM_ERR,   /*!< Talise API layer ARM error handler */
    TAL_ERRHDL_ARM_CMD_ERR, /*!< Talise sendArmCommand error handler */
    TAL_ERRHDL_ARM_INITCALS_ERR, /*!< Talise init calibration error handler */
    TAL_ERRHDL_API_GPIO,   /*!< Talise GPIO error handler */
    TAL_ERRHDL_API_C0_PCA,   /*!< reserved error handler */
    TAL_ERRHDL_API_C0_PHMFOVR  /*!< reserved error handler */
} taliseErrHdls_t;

/**
 *  \brief Enumerated list of Talise Recovery Actions used as return values
 *         APIs.
 */
typedef enum
{
    TALACT_NO_ACTION = 0,            /*!< API OK - NO ACTION REQUIRED */
    TALACT_WARN_RESET_LOG,           /*!< API OK - LOG Not working */
    TALACT_WARN_RERUN_TRCK_CAL,      /*!< API NG - RESET  SPEC TRACK CALS */
    TALACT_WARN_RESET_GPIO,          /*!< API OK - GPIO Not working */
    TALACT_ERR_CHECK_TIMER,          /*!< API OK - timer not working */
    TALACT_ERR_RESET_ARM,            /*!< API NG - RESET ARM ONLY */
    TALACT_ERR_RERUN_INIT_CALS,      /*!< API NG - RESET INIT CAL SEQ */
    TALACT_ERR_RESET_SPI,            /*!< API NG - SPI Not Working */
    TALACT_ERR_RESET_GPIO,           /*!< API NG - GPIO Not working */
    TALACT_ERR_CHECK_PARAM,          /*!< API OK - INVALID PARAM */
    TALACT_ERR_RESET_FULL,           /*!< API NG - FULL RESET REQUIRED */
    TALACT_ERR_RESET_JESD204FRAMERA, /*!< API NG - RESET the JESD204 FRAMER A */
    TALACT_ERR_RESET_JESD204FRAMERB, /*!< API NG - RESET the JESD204 FRAMER B */
    TALACT_ERR_RESET_JESD204DEFRAMERA, /*!< API NG - RESET the JESD204 DEFRAMER A */
    TALACT_ERR_RESET_JESD204DEFRAMERB, /*!< API NG - RESET the JESD204 DEFRAMER B */
    TALACT_ERR_BBIC_LOG_ERROR,           /*!< API NG - USER Should log this error and decide recovery action */
    TALACT_ERR_REDUCE_TXSAMPLE_PWR     /*!< API NG - RESET the TX Sample power for the Channel specified */
} talRecoveryActions_t;

#ifdef __cplusplus
}
#endif

#endif /* TALISE_ERROR_TYPES_H_ */
/**
 * \file talise_gpio_types.h
 * \brief Contains functions to allow control of the General Purpose IO functions on the Talise device
 *
 * Talise API version: 3.4.0.0
 *
 * Copyright 2015-2017 Analog Devices Inc.
 * Released under the AD9378-AD9379 API license, for more information see the "LICENSE.txt" file in this zip file.
 */

#ifndef TALISE_GPIO_TYPES_H_
#define TALISE_GPIO_TYPES_H_

#ifdef __cplusplus
extern "C" {
#endif

/**
 *  \brief Enum to set the low voltage GPIO mode
 */
typedef enum
{
    TAL_GPIO_MONITOR_MODE = 0, /*!< Allows a choice of debug signals to output from Talise to monitor the state of the device */
    TAL_GPIO_BITBANG_MODE = 3, /*!< Manual mode, API function sets output pin levels and reads input pin levels */
    TAL_GPIO_ARM_OUT_MODE = 9,  /*!< Allows internal ARM processor to output on GPIO pins */
    TAL_GPIO_SLICER_OUT_MODE = 10  /*!< Allows Slicer active configuration to the GPIO output  pins */
} taliseGpioMode_t;

/**
 *  \brief Enum of unique error codes for the Talise GPIO API functions.
 * Each error condition in the library should get its own enum value to allow
 * easy debug of errors.
 */
typedef enum
{
    TALISE_ERR_GPIO_OK = 0,
    TALISE_ERR_MONITOR_OUT_INDEX_RANGE,
    TALISE_ERR_GETGPIOMON_INDEX_NULL_PARM,
    TALISE_ERR_GETGPIOMON_MONITORMASK_NULL_PARM,
    TALISE_ERR_GETGPIO_OE_NULL_PARM,
    TALISE_ERR_GPIO_OE_INV_PARM,
    TALISE_ERR_GPIO_SRC_INV_PARM,
    TALISE_ERR_GETGPIO_SRC_NULL_PARM,
    TALISE_ERR_GPIO_LEVEL_INV_PARM,
    TALISE_ERR_GETGPIO_LEVEL_NULL_PARM,
    TALISE_ERR_GETGPIO_SETLEVEL_NULL_PARM,
    TALISE_ERR_SETUPAUXDAC_NULL_PARM,
    TALISE_ERR_SETUPAUXDAC_INV_10BIT_AUXDACCODE,
    TALISE_ERR_SETUPAUXDAC_INV_12BIT_AUXDACCODE,
    TALISE_ERR_WRITEAUXDAC_INV_10BIT_AUXDACCODE,
    TALISE_ERR_WRITEAUXDAC_INV_12BIT_AUXDACCODE,
    TALISE_ERR_WRITEAUXDAC_INV_AUXDACINDEX,
    TALISE_ERR_SETUPAUXDAC_INV_RESOLUTION,
    TALISE_ERR_GPIO3V3_OE_INV_PARM,
    TALISE_ERR_GETGPIO3V3_OE_NULL_PARM,
    TALISE_ERR_GPINT_OK,
    TALISE_ERR_GPINT_STATUS_NULL_PARM,
    TALISE_ERR_GPINT_GPINTDIAG_NULL_PARM,
    TALISE_ERR_GPINT_NO_SOURCE_FOUND,
    TALISE_ERR_GPINT_SOURCE_NOT_IMPLEMENTED,
    TALISE_ERR_GPINT_CLKPLL_UNLOCKED,
    TALISE_ERR_GPINT_RFPLL_UNLOCKED,
    TALISE_ERR_GPINT_AUXPLL_UNLOCKED,
    TALISE_ERR_GPINT_ARM_WATCHDOG_TIMEOUT,
    TALISE_ERR_GPINT_ARM_FORCE_GPINT,
    TALISE_ERR_GPINT_ARM_SYSTEM_ERROR,
    TALISE_ERR_GPINT_ARM_DATA_PARITY_ERROR,
    TALISE_ERR_GPINT_ARM_PROG_PARITY_ERROR,
    TALISE_ERR_GPINT_ARM_CALIBRATION_ERROR,
    TALISE_ERR_GPINT_FRAMERA,
    TALISE_ERR_GPINT_DEFRAMERA,
    TALISE_ERR_GPINT_FRAMERB,
    TALISE_ERR_GPINT_DEFRAMERB,
    TALISE_ERR_GPINT_PA_PROTECT_CH1,
    TALISE_ERR_GPINT_PA_PROTECT_CH2,
    TALISE_ERR_GPINT_STREAM_ERROR,
    TALISE_ERR_SETAUXADCPINMODEGPIO_INV_GPIO,
    TALISE_ERR_SETAUXADCPINMODEGPIO_GPIO_IN_USE,
    TALISE_ERR_STARTAUXADC_INV_CHANNEL,
    TALISE_ERR_STARTAUXADC_INV_MODE,
    TALISE_ERR_STARTAUXADC_INV_NUM_SAMPLES,
    TALISE_ERR_STARTAUXADC_INV_SAMPLING_PERIOD,
    TALISE_ERR_STARTAUXADC_NULL_PARAM,
    TALISE_ERR_READAUXADC_NULL_PARAM,
    TAL_ERR_GPIO_NUMBER_OF_ERRORS /* Keep this ENUM last as a reference to the total number of error enum values */
} taliseGpioErr_t;

/**
 * \brief Enumeration for 10bit AuxDAC voltage for center DAC code (code 512).
 */
typedef enum
{
    TAL_AUXDACVREF_1V = 0, /*!< AuxDAC reference at 1V */
    TAL_AUXDACVREF_1P5V = 1, /*!< AuxDAC reference at 1.5V */
    TAL_AUXDACVREF_2V = 2, /*!< AuxDAC reference at 2V */
    TAL_AUXDACVREF_2P5V = 3 /*!< AuxDAC reference at 2.5V */
} taliseAuxDacVref_t;

typedef enum
{
    TAL_AUXDACRES_12BIT = 0, /*!< 12bit DAC resolution for a subset of the output voltage range centered around VREF */
    TAL_AUXDACRES_11BIT = 1, /*!< 11bit DAC resolution for a subset of the output voltage range centered around VREF */
    TAL_AUXDACRES_10BIT = 2  /*!< 10bit DAC resolution for 100mv to 3v range */
} taliseAuxDacResolution_t;

/**
 * \brief Data structure to hold the auxiliary DAC settings
 */
typedef struct
{
    uint16_t                 auxDacEnables;         /*!< Aux DAC enable bit for each DAC, where the first ten bits correspond to the 10-bit DACs, and the next consecutive two bits enable the 12-bit DACs */
    taliseAuxDacVref_t       auxDacVref[10];        /*!< Aux DAC voltage reference value for each of the 10-bit DACs */
    taliseAuxDacResolution_t auxDacResolution[10];  /*!< Aux DAC slope (resolution of voltage change per AuxDAC code) - only applies to 10bit DACs (0-9) */
    uint16_t                 auxDacValues[12];      /*!< Aux DAC values for each 10-bit DAC correspond to the first 10 array elements, the next consecutive array elements correspond to the two 12-bit DAC values */
} taliseAuxDac_t;

/**
 * \brief General Purpose interrupt mask types
 */
typedef enum
{
    TAL_GP_MASK_STREAM_ERROR            = 0x1000,   /*!< Stream processor error GP Interrupt mask bit */
    TAL_GP_MASK_ARM_CALIBRATION_ERROR   = 0x0800,   /*!< ARM calibration error GP Interrupt mask bit */
    TAL_GP_MASK_ARM_SYSTEM_ERROR        = 0x0400,   /*!< ARM System error GP Interrupt mask bit */
    TAL_GP_MASK_ARM_FORCE_INTERRPUT     = 0x0200,   /*!< ARM force GP Interrupt mask bit */
    TAL_GP_MASK_WATCHDOG_TIMEOUT        = 0x0100,   /*!< Watchdog GP Interrupt mask bit */
    TAL_GP_MASK_PA_PROTECTION_TX2_ERROR = 0x0080,   /*!< Tx2 PA protection error GP Interrupt mask bit */
    TAL_GP_MASK_PA_PROTECTION_TX1_ERROR = 0x0040,   /*!< Tx1 PA protection error GP Interrupt mask bit */
    TAL_GP_MASK_JESD_DEFRMER_IRQ        = 0x0020,   /*!< JESD204B Deframer IRQ error GP Interrupt mask bit */
    TAL_GP_MASK_JESD_FRAMER_IRQ         = 0x0010,   /*!< JESD204B Framer IRQ error GP Interrupt mask bit */
    TAL_GP_MASK_CLK_SYNTH_LOCK          = 0x0008,   /*!< Device clock PLL non-lock error GP Interrupt mask bit */
    TAL_GP_MASK_AUX_SYNTH_LOCK          = 0x0004,   /*!< Auxiliary PLL non-lock error GP Interrupt mask bit */
    TAL_GP_MASK_RF_SYNTH_LOCK           = 0x0002    /*!< RF PLL non-lock error GP Interrupt mask bit */
} taliseGpIntMask_t;

/**
 * \brief GPIO settings for SPI2 TxAtten select
 */
typedef enum
{
    TAL_SPI2_TXATTEN_GPIO4   = 0x00,    /*!< Select GPIO4 for SPI2 Tx Attenuation select */
    TAL_SPI2_TXATTEN_GPIO8   = 0x01,    /*!< Select GPIO8 for SPI2 Tx Attenuation select */
    TAL_SPI2_TXATTEN_GPIO14  = 0x02,    /*!< Select GPIO14 for SPI2 Tx Attenuation select */
    TAL_SPI2_TXATTEN_DISABLE = 0x03     /*!< Disable GPIO for SPI2 Tx Attenuation select */
} taliseSpi2TxAttenGpioSel_t;


/**
 * \brief gpIntHandler diagnostic structure
 */
typedef struct
{
    uint8_t data[9];                /*!< All GP_INT sources */
    taliseFramerSel_t framer;       /*!< Interrupting framer, valid only for framer sources */
    taliseDeframerSel_t deframer;   /*!< Interrupting deframer, valid only for deframer sources */
    int32_t deframerInputsMask;     /*!< Interrupting deframer input mask (bit per deframer input), valid only for deframer sources (valid 0x0-0xF)
                                         deframerInputsMask is the deframer lane after the deframer lane crossbar swapping (lane input of the deframer) */
} taliseGpIntInformation_t;

/**
 * \brief Talise Aux ADC Channel types
 */
typedef enum
{
    TAL_AUXADC_CH0 = 0,  /*!< Select Aux ADC Channel 0 for sampling and conversion*/
    TAL_AUXADC_CH1 = 1,  /*!< Select Aux ADC Channel 1 for sampling and conversion*/
    TAL_AUXADC_CH2 = 2,  /*!< Select Aux ADC Channel 2 for sampling and conversion*/
    TAL_AUXADC_CH3 = 3   /*!< Select Aux ADC Channel 3 for sampling and conversion*/
} taliseAuxAdcChannels_t;

/**
 * \brief Talise Aux ADC modes for sampling
 */
typedef enum
{
    TAL_AUXADC_NONPIN_MODE = 0,  /*!< Select Aux ADC sampling and conversion in Non-Pin mode (ARM Internal timer is used for sampling and conversion)*/
    TAL_AUXADC_PIN_MODE    = 1   /*!< Select Aux ADC sampling and conversion in Pin mode (Pulses on ARM GPIO Input pins are used to schedule sampling and conversion)*/
} taliseAuxAdcModes_t;

/**
 * \brief Talise Aux ADC configuration structure
 */
typedef struct
{
    taliseAuxAdcChannels_t auxAdcChannelSel;  /*!< Selects the channel which is supposed to sample AuxADC input for A/D conversion */
    taliseAuxAdcModes_t    auxAdcMode;        /*!< Selects mode to latch and store conversion results */
    uint16_t               numSamples;        /*!< No. of A/D conversions to be performed in range 1 - 1000 */
    uint16_t               samplingPeriod_us; /*!< Sampling interval time in microseconds (Minimum 15us) NOTE: Valid only for non pin mode. Ignored for pin mode. */
} taliseAuxAdcConfig_t;

/**
 * \brief Talise Aux ADC conversion result structure
 */
typedef struct
{
    uint16_t auxAdcCodeAvg;     /*!< 12-bit Average of AuxADC A/D conversion samples */
    uint16_t numSamples;        /*!< No. of samples averaged in AuxAdcCodeAvg */
    uint8_t  completeIndicator; /*!< Flag to indicate if a scheduled AuxADC conversion completed. 1 - AuxADC Conversion Complete, 0 - AuxADC Conversion Incomplete */
} taliseAuxAdcResult_t;


#ifdef __cplusplus
}
#endif

#endif /* TALISE_GPIO_TYPES_H_ */
/**
 * \file talise_jesd204_types.h
 * \brief Contains Talise API JESD data types
 *
 * Talise API version: 3.4.0.0
 *
 * Copyright 2015-2017 Analog Devices Inc.
 * Released under the AD9378-AD9379 API license, for more information see the "LICENSE.txt" file in this zip file.
 */

#ifndef TALISE_JESD204_TYPES_H_
#define TALISE_JESD204_TYPES_H_

#ifdef __cplusplus
extern "C" {
#endif

/**
 *  \brief Enum to select desired framer
 */
typedef enum
{
    TAL_FRAMER_A = 0,       /*!< Framer A selection */
    TAL_FRAMER_B,           /*!< Framer B selection */
    TAL_FRAMER_A_AND_B      /*!< Used for cases where Rx1 uses one framer, Rx2 uses the second framer */
} taliseFramerSel_t;

/**
 *  \brief Enum to select desired deframer
 */
typedef enum
{
    TAL_DEFRAMER_A = 0,    /*!< Deframer A selection */
    TAL_DEFRAMER_B,        /*!< Deframer B selection */
    TAL_DEFRAMER_A_AND_B   /*!< Used for cases where Tx1 uses one deframer, Tx2 uses the second deframer */
} taliseDeframerSel_t;

/**
 * \brief Enumerated list of DAC Sample Xbar options
 */
typedef enum
{
    TAL_DEFRAMERA_OUT0 = 0x0,               /*!< Link 0, Deframer out 0 */
    TAL_DEFRAMERA_OUT1 = 0x1,               /*!< Link 0, Deframer out 1 */
    TAL_DEFRAMERA_OUT2 = 0x2,               /*!< Link 0, Deframer out 2 */
    TAL_DEFRAMERA_OUT3 = 0x3,               /*!< Link 0, Deframer out 3 */
    TAL_DEFRAMERB_OUT0 = 0x4,               /*!< Link 1, Deframer out 0 */
    TAL_DEFRAMERB_OUT1 = 0x5,               /*!< Link 1, Deframer out 1 */
    TAL_DEFRAMERB_OUT2 = 0x6,               /*!< Link 1, Deframer out 2 */
    TAL_DEFRAMERB_OUT3 = 0x7                /*!< Link 1, Deframer out 3 */
} taliseDacSampleXbarSelect_t;

/**
 * \brief Enumerated list of ADC Sample Xbar options
 */
typedef enum
{
    TAL_ADC_RX1_I = 0x0,                    /*!<  Rx1 I data */
    TAL_ADC_RX1_Q = 0x1,                    /*!<  Rx1 Q data */
    TAL_ADC_RX2_I = 0x2,                    /*!<  Rx2 I data */
    TAL_ADC_RX2_Q = 0x3,                    /*!<  Rx2 Q data */
    TAL_ADC_DUALBAND_RX1_BAND_A_I = 0x0,    /*!<  Dualband Rx1 Band A I data */
    TAL_ADC_DUALBAND_RX1_BAND_A_Q = 0x1,    /*!<  Dualband Rx1 Band A Q data */
    TAL_ADC_DUALBAND_RX2_BAND_A_I = 0x2,    /*!<  Dualband Rx2 Band A I data */
    TAL_ADC_DUALBAND_RX2_BAND_A_Q = 0x3,    /*!<  Dualband Rx2 Band A Q data */
    TAL_ADC_DUALBAND_RX1_BAND_B_I = 0x4,    /*!<  Dualband Rx1 Band B I data */
    TAL_ADC_DUALBAND_RX1_BAND_B_Q = 0x5,    /*!<  Dualband Rx1 Band B Q data */
    TAL_ADC_DUALBAND_RX2_BAND_B_I = 0x6,    /*!<  Dualband Rx2 Band B I data */
    TAL_ADC_DUALBAND_RX2_BAND_B_Q = 0x7     /*!<  Dualband Rx2 Band B Q data */

} taliseAdcSampleXbarSelect_t;

/**
 * \brief Enum of possible Framer Test Data sources
 */
typedef enum
{
    TAL_FTD_ADC_DATA = 0,           /*!< Framer test data ADC data source */
    TAL_FTD_CHECKERBOARD,           /*!< Framer test data checkerboard data source */
    TAL_FTD_TOGGLE0_1,              /*!< Framer test data toggle 0 to 1 data source */
    TAL_FTD_PRBS31,                 /*!< Framer test data PRBS31 data source */
    TAL_FTD_PRBS23,                 /*!< Framer test data PRBS23 data source */
    TAL_FTD_PRBS15,                 /*!< Framer test data PRBS15 data source */
    TAL_FTD_PRBS9,                  /*!< Framer test data PRBS9 data source */
    TAL_FTD_PRBS7,                  /*!< Framer test data PRBS7 data source */
    TAL_FTD_RAMP,                   /*!< Framer test data ramp data source */
    TAL_FTD_PATTERN_REPEAT = 14,    /*!< Framer test data 16-bit programmed pattern repeat source */
    TAL_FTD_PATTERN_ONCE = 15       /*!< Framer test data 16-bit programmed pattern executed once source */

} taliseFramerDataSource_t;

/**
 *  \brief Enum of Framer test data injection points
 */
typedef enum
{
    TAL_FTD_FRAMERINPUT = 0,        /*!< Framer test data injection point at framer input */
    TAL_FTD_SERIALIZER,             /*!< Framer test data injection point at serializer input */
    TAL_FTD_POST_LANEMAP            /*!< Framer test data injection point after lane mapping */

} taliseFramerInjectPoint_t;

/**
 * \brief Enum for JESD204B PRBS generated types
 */
typedef enum
{
    TAL_PRBS_DISABLE = 0,       /*!< Deframer PRBS pattern disable */
    TAL_PRBS7,                  /*!< Deframer PRBS7 pattern select */
    TAL_PRBS15,                 /*!< Deframer PRBS15 pattern select */
    TAL_PRBS31                  /*!< Deframer PRBS31 pattern select */

} taliseDeframerPrbsOrder_t;

/**
 * \brief Enum for JESD204B deserializer / deframer PRBS selection
 */
typedef enum
{
    TAL_PRBSCHECK_LANEDATA = 0, /*!< Check PRBS at deserializer lane output (does not require JESD204b link) */
    TAL_PRBSCHECK_SAMPLEDATA    /*!< Check PRBS at output of deframer (JESD204b deframed sample) */

} taliseDefPrbsCheckLoc_t;

/**
 * \brief Data structure to hold the DAC sample crossbar information
 */
typedef struct
{
    taliseDacSampleXbarSelect_t dacChanI;    /*!< Sample Crossbar select for I channel data*/
    taliseDacSampleXbarSelect_t dacChanQ;    /*!< Sample Crossbar select for Q channel data*/
} taliseDacSampleXbar_t;

/**
 * \brief Data structure to hold the ADC sample crossbar information
 */
typedef struct
{
    taliseAdcSampleXbarSelect_t conv0;    /*!< Sample Crossbar select for converter 0*/
    taliseAdcSampleXbarSelect_t conv1;    /*!< Sample Crossbar select for converter 1*/
    taliseAdcSampleXbarSelect_t conv2;    /*!< Sample Crossbar select for converter 2*/
    taliseAdcSampleXbarSelect_t conv3;    /*!< Sample Crossbar select for converter 3*/
    taliseAdcSampleXbarSelect_t conv4;    /*!< Sample Crossbar select for converter 4*/
    taliseAdcSampleXbarSelect_t conv5;    /*!< Sample Crossbar select for converter 5*/
    taliseAdcSampleXbarSelect_t conv6;    /*!< Sample Crossbar select for converter 6*/
    taliseAdcSampleXbarSelect_t conv7;    /*!< Sample Crossbar select for converter 7*/
} taliseAdcSampleXbar_t;

/**
 *  \brief Data structure to hold Talise JESD204b DeFramer ILAS configuration settings
 */
typedef struct
{
  uint8_t DID;                          /*!< JESD204B Configuration Device ID for ILAS check */
  uint8_t BID;                          /*!< JESD204B Configuration Bank ID for ILAS check */
  uint8_t LID0;                         /*!< JESD204B Configuration starting Lane ID for ILAS check */
  uint8_t L;                            /*!< JESD204B Configuration L = lanes per data converter for ILAS check */
  uint8_t SCR;                          /*!< JESD204B Configuration scramble setting for ILAS check */
  uint8_t F;                            /*!< JESD204B Configuration F = octets per frame for ILAS check */
  uint8_t K;                            /*!< JESD204B Configuration K = frames per multiframe for ILAS check */
  uint8_t M;                            /*!< JESD204B Configuration M = number of data converters for ILAS check */
  uint8_t N;                            /*!< JESD204B Configuration N = data converter sample resolution for ILAS check */
  uint8_t CS;                           /*!< JESD204B Configuration CS = number of control bits transferred per sample per frame for ILAS check */
  uint8_t NP;                           /*!< JESD204B Configuration NP = JESD204B word size based on the highest resolution of the data converter for ILAS check */
  uint8_t S;                            /*!< JESD204B Configuration S = number of samples/data converter/frame for ILAS check */
  uint8_t CF;                           /*!< JESD204B Configuration CF = '0' = control bits appended to each sample, '1' = appended to end of frame for ILAS check */
  uint8_t HD;                           /*!< JESD204B Configuration HD = high density bit - samples are contained within lane (0) or divided over more than one lane (1) for ILAS check */
  uint8_t FCHK0;                        /*!< JESD204B Configuration checksum for ILAS check lane0 */
  uint8_t FCHK1;                        /*!< JESD204B Configuration checksum for ILAS check lane1 */
  uint8_t FCHK2;                        /*!< JESD204B Configuration checksum for ILAS check lane2 */
  uint8_t FCHK3;                        /*!< JESD204B Configuration checksum for ILAS check lane3 */
} taliseJesd204bLane0Config_t;

/**
 *  \brief Data structure to hold Talise JESD204b Framer configuration settings
 */
typedef struct
{
    uint8_t bankId;                     /*!< JESD204B Configuration Bank ID extension to Device ID. Range is 0..15 */
    uint8_t deviceId;                   /*!< JESD204B Configuration Device ID link identification number. Range is 0..255 */
    uint8_t lane0Id;                    /*!< JESD204B Configuration starting Lane ID. If more than one lane is used, each lane will increment from the Lane0 ID. Range is 0..31 */
    uint8_t M;                          /*!< Number of ADCs (0, 2, or 4) where 2 ADCs are required per receive chain (I and Q) */
    uint8_t K;                          /*!< Number of frames in a multiframe. Default = 32, F*K must be modulo 4. Where, F=2*M/numberOfLanes */
    uint8_t F;                          /*!< Number of bytes(octets) per frame (Valid 1, 2, 4, 8) */
    uint8_t Np;                         /*!< converter sample resolution (12, 16, 24) */
    uint8_t scramble;                   /*!< Scrambling off if framerScramble = 0, if framerScramble > 0 scrambling is enabled */
    uint8_t externalSysref;             /*!< External SYSREF select. 0 = use internal SYSREF(not currently valid), 1 = use external SYSREF */
    uint8_t serializerLanesEnabled;     /*!< Serializer lane select bit field. Where, [0] = Lane0 enabled, [1] = Lane1 enabled, etc */
    uint8_t serializerLaneCrossbar;     /*!< Lane crossbar to map framer lane outputs to physical lanes */
    uint8_t lmfcOffset;                 /*!< LMFC offset value for deterministic latency setting.  Range is 0..31 */
    uint8_t newSysrefOnRelink;          /*!< Flag for determining if SYSREF on relink should be set. Where, if > 0 = set, 0 = not set */
    uint8_t syncbInSelect;              /*!< Selects SYNCb input source. Where, 0 = use SYNCBIN0 for this framer, 1 = use SYNCBIN1 for this framer */
    uint8_t overSample;                 /*!< Selects framer bit repeat or oversampling mode for lane rate matching. Where, 0 = bitRepeat mode (changes effective lanerate), 1 = overSample (maintains same lane rate between ObsRx framer and Rx framer and oversamples the ADC samples) */
    uint8_t syncbInLvdsMode;            /*!< 1 - enable LVDS input pad with 100ohm internal termination, 0 - enable CMOS input pad */
    uint8_t syncbInLvdsPnInvert;        /*!< 0 - syncb LVDS PN not inverted, 1 - syncb LVDS PN inverted */
    uint8_t enableManualLaneXbar;       /*!< 0 - Automatic Lane crossbar mapping, 1 - Manual Lane crossbar mapping (use serializerLaneCrossbar value with no checking) */
} taliseJesd204bFramerConfig_t;

/**
* \brief Data structure to hold the settings for the deframer configuration
*/
typedef struct
{
    uint8_t bankId;                     /*!< Extension to Device ID. Range is 0..15 */
    uint8_t deviceId;                   /*!< Link identification number. Range is 0..255 */
    uint8_t lane0Id;                    /*!< Lane0 ID. Range is 0..31 */
    uint8_t M;                          /*!< Number of DACs (0, 2, or 4) - 2 DACs per transmit chain (I and Q) */
    uint8_t K;                          /*!< Number of frames in a multiframe. Default = 32, F*K = modulo 4. Where, F=2*M/numberOfLanes */
    uint8_t scramble;                   /*!< Scrambling off if scramble = 0, if framerScramble > 0 scrambling is enabled */
    uint8_t externalSysref;             /*!< External SYSREF select. 0 = use internal SYSREF, 1 = external SYSREF */
    uint8_t deserializerLanesEnabled;   /*!< Deserializer lane select bit field. Where, [0] = Lane0 enabled, [1] = Lane1 enabled, etc */
    uint8_t deserializerLaneCrossbar;   /*!< Lane crossbar to map deframer lane outputs to physical lanes */
    uint8_t lmfcOffset;                 /*!< LMFC offset value to adjust deterministic latency. Range is 0..31 */
    uint8_t newSysrefOnRelink;          /*!< Flag for determining if SYSREF on relink should be set. Where, if > 0 = set, '0' = not set */
    uint8_t syncbOutSelect;             /*!< Selects deframer SYNCBOUT pin (0 = SYNCBOUT0, 1 = SYNCBOUT1) */
    uint8_t Np;                         /*!< converter sample resolution (12, 16) */
    uint8_t syncbOutLvdsMode;           /*!< 1 - enable LVDS output pad, 0 - enable CMOS output pad  */
    uint8_t syncbOutLvdsPnInvert;       /*!< 0 - syncb LVDS PN not inverted, 1 - syncb LVDS PN inverted */
    uint8_t syncbOutCmosSlewRate;       /*!< 0 - fastest rise/fall times, 3 - slowest rise/fall times */
    uint8_t syncbOutCmosDriveLevel;     /*!< 0 - normal cmos drive level, 1 - double cmos drive level */
    uint8_t enableManualLaneXbar;       /*!< 0 - Automatic Lane crossbar mapping, 1 - Manual Lane crossbar mapping (use deserializerLaneCrossbar value with no checking) */
} taliseJesd204bDeframerConfig_t;

/**
 *  \brief Data structure to hold Talise JESD204b Framer and Deframer configuration information
 */
typedef struct
{
    taliseJesd204bFramerConfig_t framerA;       /*!< Framer A configuration data structure */
    taliseJesd204bFramerConfig_t framerB;       /*!< Framer B configuration data structure */
    taliseJesd204bDeframerConfig_t deframerA;   /*!< Deframer A configuration data structure */
    taliseJesd204bDeframerConfig_t deframerB;   /*!< Deframer A configuration data structure */
    uint8_t serAmplitude;                       /*!< Serializer amplitude setting. Default = 15. Range is 0..15 */
    uint8_t serPreEmphasis;                     /*!< Serializer pre-emphasis setting. Default = 1 Range is 0..4 */
    uint8_t serInvertLanePolarity;              /*!< Serializer Lane PN inversion select. Default = 0. Where, bit[0] = 1 will invert lane [0], bit[1] = 1 will invert lane 1, etc. */
    uint8_t desInvertLanePolarity;              /*!< Deserializer Lane PN inversion select.  bit[0] = 1 Invert PN of Lane 0, bit[1] = Invert PN of Lane 1, etc */
    uint8_t desEqSetting;                       /*!< Deserializer Equalizer setting. Applied to all deserializer lanes. Range is 0..2 (default 2, 0 = max boost) */
    uint8_t sysrefLvdsMode;                     /*!< 1 - enable LVDS Input pad with 100ohm internal termination, 0 - enable CMOS input pad */
    uint8_t sysrefLvdsPnInvert;                 /*!< 0 - sysref LVDS PN is not inverted, 1 - sysref LVDS PN is inverted */
} taliseJesdSettings_t;


#ifdef __cplusplus
}
#endif

#endif /* TALISE_JESD204_TYPES_H_ */
/**
 * \file talise_radioctrl_types.h
 * \brief Contains Talise API Radio Control data types
 *
 * Talise API version: 3.4.0.0
 *
 * Copyright 2015-2017 Analog Devices Inc.
 * Released under the AD9378-AD9379 API license, for more information see the "LICENSE.txt" file in this zip file.
 */

#ifndef TALISE_RADIOCTRL_TYPES_H_
#define TALISE_RADIOCTRL_TYPES_H_

#ifdef __cplusplus
extern "C" {
#endif

/**
 *  \brief Enum to select desired low voltage GPIO pin used by the API
 */
typedef enum
{
    TAL_GPIO_00 = 0,
    TAL_GPIO_01,
    TAL_GPIO_02,
    TAL_GPIO_03,
    TAL_GPIO_04,
    TAL_GPIO_05,
    TAL_GPIO_06,
    TAL_GPIO_07,
    TAL_GPIO_08,
    TAL_GPIO_09,
    TAL_GPIO_10,
    TAL_GPIO_11,
    TAL_GPIO_12,
    TAL_GPIO_13,
    TAL_GPIO_14,
    TAL_GPIO_15,
    TAL_GPIO_16,
    TAL_GPIO_17,
    TAL_GPIO_18,
    TAL_GPIO_INVALID

} taliseGpioPinSel_t;

/**
 *  \brief Enum to select desired External LO output frequency = RFPLL VCO / 2 / ExtLoDiv
 *  Where ExtLoDiv is a power of 2 from (1, 2, 4, 8, 16, 32, 64)
 */
typedef enum
{
    TAL_EXTLO_RFPLLVCO_DIV2 =  0,  /*!< External LO output in frequency range 3000 MHz    - 6000 MHz   */
    TAL_EXTLO_RFPLLVCO_DIV4 =  1,  /*!< External LO output in frequency range 1500 MHz    - 3000 MHz   */
    TAL_EXTLO_RFPLLVCO_DIV8 =  2,  /*!< External LO output in frequency range  750 MHz    - 1500 MHz   */
    TAL_EXTLO_RFPLLVCO_DIV16 = 3,  /*!< External LO output in frequency range  375 Mhz    -  750 MHz   */
    TAL_EXTLO_RFPLLVCO_DIV32 = 4,  /*!< External LO output in frequency range  187.5 MHz  -  375 MHz   */
    TAL_EXTLO_RFPLLVCO_DIV64 = 5   /*!< External LO output in frequency range   93.75 MHz -  187.5 MHz */
} taliseExtLoDiv_t;
/**
 * \brief Data structure to hold ARM GPIO pin assignments, polarity, and pin enable for the Talise ARM
 */
typedef struct
{
    taliseGpioPinSel_t gpioPinSel; /*!< Select desired GPIO pin to input into Talise (valid 0-15) */
    uint8_t polarity;           /*!< Signal polarity (0 = Normal polarity, 1=Talise will invert the signal before using) */
    uint8_t enable;             /*!< 1 = Enable Talise ARM use of GPIO signal, 0 = Talise ARM uses ARM command to set this signal value */

} taliseArmGpioPinSettings_t;


/**
 * \brief Data structure to hold ARM GPIO pin assignments for each ARM input/output pin.
 */
typedef struct
{
    /* Talise ARM input GPIO pins -- Only valid if orxPinMode = 1 */
    taliseArmGpioPinSettings_t orx1TxSel0Pin;      /*!< Select desired GPIO pin to input into Talise(valid 0-15), polarity, enable */
    taliseArmGpioPinSettings_t orx1TxSel1Pin;      /*!< Select desired GPIO pin to input into Talise(valid 0-15), polarity, enable */
    taliseArmGpioPinSettings_t orx2TxSel0Pin;      /*!< Select desired GPIO pin to input into Talise(valid 0-15), polarity, enable */
    taliseArmGpioPinSettings_t orx2TxSel1Pin;      /*!< Select desired GPIO pin to input into Talise(valid 0-15), polarity, enable */
    taliseArmGpioPinSettings_t enTxTrackingCals;   /*!< Select desired GPIO pin to input into Talise(valid 0-15), polarity, enable */

} taliseArmGpioConfig_t;

/**
 * \brief Enumerated list of Radio Control Config2 ORx1/ORx2 GPIO pin pair settings
 */
typedef enum
{
    TAL_ORX1ORX2_PAIR_01_SEL = 0x00,   /*!< Radio Control Config 2 ORx1/ORx2 GPIO '0,1' pin pair select */
    TAL_ORX1ORX2_PAIR_45_SEL,          /*!< Radio Control Config 2 ORx1/ORx2 GPIO '4,5' pin pair select */
    TAL_ORX1ORX2_PAIR_89_SEL,          /*!< Radio Control Config 2 ORx1/ORx2 GPIO '8,9' pin pair select */
    TAL_ORX1ORX2_PAIR_NONE_SEL         /*!< Radio Control Config 2 ORx1/ORx2 GPIO 'none' pin pair select */

} taliseRadioCtlCfg2_t;

/**
 * \brief Enumerated list of Radio Control Config1 register bits
 */
typedef enum
{
    TAL_TXRX_PIN_MODE = 0x01,       /*!< Radio Control Config 1 bit '0' mask */
    TAL_ORX_PIN_MODE = 0x02,        /*!< Radio Control Config 1 bit '1' mask */
    TAL_ORX_USES_RX_PINS = 0x04,    /*!< Radio Control Config 1 bit '2' mask */
    TAL_ORX_SEL = 0x10,             /*!< Radio Control Config 1 bit '4' mask */
    TAL_ORX_SINGLE_CHANNEL = 0x20,  /*!< Radio Control Config 1 bit '5' mask */
    TAL_ORX_ENAB_SEL_PIN = 0x40     /*!< Radio Control Config 1 bit '6' mask */
} taliseRadioCtlCfg1_t;

/**
 *  \brief Enum of possible Rx and ORx stream processor enables to be used with
 *         the TALISE_setRxTxEnable() function
 */
typedef enum
{
    TAL_RXOFF_EN    = 0x00,  /*!< All Rx/ORx channels off */
    TAL_RX1_EN      = 0x01,  /*!< Rx1 channel enabled */
    TAL_RX2_EN      = 0x02,  /*!< Rx2 channel enabled */
    TAL_RX1RX2_EN   = 0x03,  /*!< Rx1 + Rx2 channels enabled */
    TAL_ORX1_EN     = 0x04,  /*!< ORx1 channel enabled */
    TAL_ORX2_EN     = 0x08,  /*!< ORx2 channel enabled */
    TAL_ORX1ORX2_EN = 0x0C 	 /*!< ORx1 and ORx2 channels enabled - only allowed if ADC stitching is not enabled */

} taliseRxORxChannels_t;

/**
 * \brief Enumerated list of Tx to ORx mapping selections
 */
typedef enum
{
    TAL_MAP_NONE = 0,           /*!< No Tx to ORx mapping select */
    TAL_MAP_TX1_ORX = 0x02,     /*!< Tx1 to ORx mapping select */
    TAL_MAP_TX2_ORX = 0x03      /*!< Tx2 to ORx mapping select */

} taliseTxToOrxMapping_t;

/**
 *  \brief Enum of PLL selections
 */
typedef enum
{
    TAL_CLK_PLL = 0,                /*!< Selects CLK PLL for Rx and Tx */
    TAL_RF_PLL,                     /*!< Selects RF PLL for Rx and Tx */
    TAL_AUX_PLL                     /*!< Selects AUX PLL for Rx and tx*/

} taliseRfPllName_t;

/**
 * \brief Structure to setup/enable ORx LO Selection feature
 */
typedef struct
{
    uint8_t disableAuxPllRelocking; /*!< Disables the ARM from automatically relocking the Aux PLL.
                                         Set to 1 when using AuxLO as ORx LO source, 0 = default when RFPLL used as ORx LO source */
    taliseGpioPinSel_t gpioSelect;  /*!< TAL_GPIO_INVALID = disable pin mode, GPIO0-15 valid */
} taliseOrxLoCfg_t;

/**
 *  \brief Enum of FHM Exit Mode Selections
 */
typedef enum
{
    TAL_FHM_QUICK_EXIT = 0,  /*!< Selects quick exit mode on frequency hopping disable. In this case RF PLL bandwidth is left unchanded */
    TAL_FHM_FULL_EXIT        /*!< Selects full exit mode on frequency hopping disable. RF PLL Loop B/W is restored to narrowband.
                                  RF and Aux PLLs recalibrated and tracking cals resumed. */
} taliseFhmExitMode_t;

/**
 *  \brief Enum of FHM Trigger Mode Selections
 */
typedef enum
{
    TAL_FHM_GPIO_MODE = 0,       /*!< Selects FHM trigger mode as GPIO. A low to high pulse triggers frequency hop */
    TAL_FHM_NON_GPIO_MODE,       /*!< Selects FHM trigger mode as non-GPIO. An ARM command triggers frequency hop */
    TAL_FHM_INVALID_TRIGGER_MODE
} taliseFhmTriggerMode_t;

/**
 * \brief Structure to setup talise frequency hopping config
 */
typedef struct
{
    taliseGpioPinSel_t fhmGpioPin; /*!< Maps the Talise ARM GPIO pin(TAL_GPIO_0 - TAL_GPIO_15) for frequency hopping. A low to high pulse on this pin triggers freq hopping
                                        Setting fhmGpioPin = TAL_GPIO_INVALID will unassign ARM GPIO pin mapped to Rf Pll Frequency hopping*/
    uint32_t fhmMinFreq_MHz;       /*!< Sets frequency hopping range minimum frequency */
    uint32_t fhmMaxFreq_MHz;       /*!< Sets frequency hopping range maximum frequency */
} taliseFhmConfig_t;

/**
 * \brief Structure to setup talise frequency hopping mode settings
 */
typedef struct
{
    uint8_t fhmEnable;                      /*!< 0 - Disables Frequency Hopping, 1 - Enables Frequency Hopping */
    uint8_t enableMcsSync;                  /*!< 0 - Disables MCS Synchronization on FHM enable, 1 - Enables MCS Synchronization on FHM enable. Ignored if fhmEnable = 0 */
    taliseFhmTriggerMode_t fhmTriggerMode;  /*!< TAL_FHM_GPIO_MODE - Frequency Hop triggered via GPIO low to high pulse
                                                 TAL_FHM_NON_GPIO_MODE - Frequency Hop triggered via ARM command*/
    taliseFhmExitMode_t fhmExitMode;        /*!< TAL_FHM_QUICK_EXIT = quick exit on frequency hopping disable,
                                                 TAL_FHM_FULL_EXIT = Full exit on frequency hopping disable. This is ignored if fhmEnable = 1*/
    uint64_t fhmInitFrequency_Hz;           /*!< First hop frequency that Rf Pll is configured to on enabling FHM */
} taliseFhmMode_t;

/**
 * \brief Structure to read talise frequency hopping mode status
 */
typedef struct
{
   uint16_t currentFhmCmdErrorStatus;     /*!< Current FHM Enter Command Error Status. This is same as the mailbox command error status for FHM */
   uint16_t currentFhmHopErrorStatus;     /*!< Currently active FHM errors during frequency hopping */
   uint32_t numFhmHops;                   /*!< Total no. of Hops since entering FHM */
   uint32_t numFhmNoErrorEvents;          /*!< Total no. of NO FHM error events */
   uint64_t lastFhmNoErrorFreq_Hz;        /*!< Last frequency for which NO Error was encountered */
   uint32_t numFhmHopsOutsideScanRange;   /*!< Total no. of Hops outside FHM scan range */
   uint64_t lastFreqOutsideScanRange_Hz;  /*!< Last frequency which was outside FHM scan range*/
   uint32_t numInvalidFhmHopFrequencies;  /*!< Invalid Hop Freq */
   uint64_t lastInvalidHopFreq_Hz;        /*!< Last Invalid Hop Freq */
   uint32_t compPllError;                 /*!< PLL LO Computation Error */
   uint64_t compPllErrorFreq_Hz;          /*!< PLL LO Computation Error frequency */
   uint32_t rfPllLockFailed;              /*!< RF PLL Lock failed */
   uint64_t rfPllLockFailedFreq_Hz;       /*!< RF PLL Lock failed frequency*/
} taliseFhmStatus_t;

#ifdef __cplusplus
}
#endif

#endif /* TALISE_RADIOCTRL_TYPES_H_ */
/**
 * \file talise_rx_types.h
 * \brief Contains Talise API Rx datapath data types
 *
 * Talise API version: 3.4.0.0
 *
 * Copyright 2015-2017 Analog Devices Inc.
 * Released under the AD9378-AD9379 API license, for more information see the "LICENSE.txt" file in this zip file.
 */

#ifndef TALISE_RX_TYPES_H_
#define TALISE_RX_TYPES_H_

#ifdef __cplusplus
extern "C" {
#endif

#include "talise_radioctrl_types.h"

/**
 *  \brief Enum of possible Rx channel enables
 */
typedef enum
{
    TAL_RXOFF = 0,      /*!< No Rx channels are enabled */
    TAL_RX1,            /*!< Rx1 channel enabled */
    TAL_RX2,            /*!< Rx2 channel enabled */
    TAL_RX1RX2          /*!< Rx1 + Rx2 channels enabled */
} taliseRxChannels_t;

/**
 *  \brief Enum of possible Observation Rx channels to enable and run calibrations for during init.
 *  Choose ENUM value that enables all channels that will be used in the system.  During system use,
 *  only one channel can be used at a time.  This is also used to alert the ARM processor
 *  which observation channels are valid for the current desired system setup.
 */
typedef enum
{
    TAL_ORXOFF      = 0x00,
    TAL_ORX1        = 0x01,
    TAL_ORX2        = 0x02,
    TAL_ORX1ORX2    = 0x03
} taliseObsRxChannels_t;

/**
 *  \brief Enum to set the Rx Gain control mode
 */
typedef enum
{
    TAL_MGC = 0,        /*!< Manual Gain Control */
    TAL_AGCFAST = 1,    /*!< 01 Fast Attack AGC Mode TDD mode */
    TAL_AGCSLOW = 2,    /*!< Slow Loop AGC FDD, TDD modes  */
    TAL_HYBRID = 3      /*!< Hybrid AGC Gain Control */
} taliseGainMode_t;

typedef struct
{
    uint8_t rxFeGain;
    uint8_t extControl;
    uint8_t adcTiaGain;
    int16_t digGain;
    uint16_t phaseOffset;
} taliseRxGainTable_t;

typedef struct
{
    uint8_t rxFeGain;
    uint8_t extControl;
    uint8_t adcTiaGain;
    int16_t digGain;
} taliseOrxGainTable_t;

/**
 *  \brief Enum to hold Talise Floating Point Formatter number of exponent bits
 */
typedef enum
{
    TAL_2_EXPONENTBITS = 0,     /*!< Floating point values have 2 exponent bits, 13 significand bits, 1 sign bit */
    TAL_3_EXPONENTBITS = 1,     /*!< Floating point values have 3 exponent bits, 12 significand bits, 1 sign bit */
    TAL_4_EXPONENTBITS = 2,     /*!< Floating point values have 4 exponent bits, 11 significand bits, 1 sign bit */
    TAL_5_EXPONENTBITS = 3      /*!< Floating point values have 5 exponent bits, 10 significand bits, 1 sign bit  */
} taliseFpExponentModes_t;

/**
 *  \brief Enum to hold Talise Floating Point Formatter rounding modes for the Rx data path
 */
typedef enum
{
    TAL_ROUND_TO_EVEN = 0,           /*!< Round floating point ties to an even value          */
    TAL_ROUNDTOWARDS_POSITIVE = 1,   /*!< Round floating point toward the positive direction  */
    TAL_ROUNDTOWARDS_NEGATIVE = 2,   /*!< Round floating point toward the negative direction  */
    TAL_ROUNDTOWARDS_ZERO = 3,       /*!< Round floating point toward the zero direction      */
    TAL_ROUND_FROM_EVEN = 4          /*!< Round floating point ties away from even value      */
} taliseFpRoundModes_t;

/**
 *  \brief Enum to hold Talise Rx attenuation values that are used when the
 *         floating point format is enabled
 */
typedef enum
{
    TAL_FPATTEN_24DB = 4,      /*!< Set Rx attenuation to 24 dB when Rx Data format set to floating point mode  */
    TAL_FPATTEN_18DB = 5,      /*!< Set Rx attenuation to 18 dB when Rx Data format set to floating point mode  */
    TAL_FPATTEN_12DB = 6,      /*!< Set Rx attenuation to 12 dB when Rx Data format set to floating point mode */
    TAL_FPATTEN_6DB = 7,       /*!< Set Rx attenuation to 6 dB when Rx Data format set to floating point mode */
    TAL_FPATTEN_0DB = 0,            /*!< Set Rx attenuation to 0 dB when Rx Data format set to floating point mode */
    TAL_FPATTEN_MINUS6DB = 1,            /*!< Set Rx attenuation to -6 dB when Rx Data format set to floating point mode */
    TAL_FPATTEN_MINUS12DB = 2,           /*!< Set Rx attenuation to -12 dB when Rx Data format set to floating point mode */
    TAL_FPATTEN_MINUS18DB = 3            /*!< Set Rx attenuation to -18 dB when Rx Data format set to floating point mode */
} taliseFpAttenSteps_t;

/**
 *  \brief Enum to select the four Data Formatting options
 */
typedef enum
{
     TAL_GAIN_COMPENSATION_DISABLED = 0,  /*!< Gain Compensation and Data Formatting are disabled */
     TAL_GAIN_WITH_FLOATING_POINT,        /*!< Gain Compensation enabled with floating point data formatting enabled and internal slicer enabled */
     TAL_GAIN_WITH_INTSLICER_NOGPIO,      /*!< Gain Compensation enabled with integer data formatting and internal slicer enabled with no GPIO Slicer Position output */
     TAL_GAIN_WITH_INTSLICER,             /*!< Gain Compensation enabled with integer data formatting and internal slicer enabled with GPIO Slicer Position output */
     TAL_GAIN_WITH_EXTERNAL_SLICER        /*!< Gain Compensation enabled with integer data formatting and external slicer enabled */
} taliseDataFormattingModes_t;

/**
 *  \brief Enum to hold Talise Gain Slicer external pin gain step size.  Slicer gain in this mode is determined by multiplying the step size by the step size selection from the base band processor.
 */
typedef enum
{
    TAL_EXTSLICER_STEPSIZE_1DB = 0,   /*!< Set Gain Slicer External gain step size to 1dB  */
    TAL_EXTSLICER_STEPSIZE_2DB,       /*!< Set Gain Slicer External gain step size to 2dB  */
    TAL_EXTSLICER_STEPSIZE_3DB,       /*!< Set Gain Slicer External gain step size to 3dB  */
    TAL_EXTSLICER_STEPSIZE_4DB        /*!< Set Gain Slicer External gain step size to 4dB  */
} taliseGainStepSize_t;

/**
 *  \brief Enum to hold Talise Rx1 Gain Slicer external pin GPIO selection options
 */
typedef enum
{
    TAL_EXTSLICER_RX1_GPIO0_1_2 = 0,      /*!< Select Rx1 Gain Slicer External GPIO0, GPIO1, GPIO2 */
    TAL_EXTSLICER_RX1_GPIO5_6_7,          /*!< Select Rx1 Gain Slicer External GPIO5, GPIO6, GPIO7 */
    TAL_EXTSLICER_RX1_GPIO8_9_10,         /*!< Select Rx1 Gain Slicer External GPIO8, GPIO9, GPIO10 */
    TAL_EXTSLICER_RX1_GPIO_DISABLE        /*!< Select Rx1 Disable Gain Slicer External GPIO */
} taliseRx1ExtSlicerGpioSelect_t;

/**
*  \brief Enum to hold Talise Rx2 Gain Slicer external pin GPIO selection options
*/
typedef enum
{
     TAL_EXTSLICER_RX2_GPIO11_12_13 = 0,   /*!< Select Rx2 Gain Slicer External GPIO11, GPIO12, GPIO13 */
     TAL_EXTSLICER_RX2_GPIO5_6_7 = 1,      /*!< Select Rx2 Gain Slicer External GPIO5, GPIO6, GPIO7 */
     TAL_EXTSLICER_RX2_GPIO_DISABLE = 3    /*!< Select Rx2 Disable Gain Slicer External GPIO */
} taliseRx2ExtSlicerGpioSelect_t;

/**
 *  \brief Enum to hold Talise integer mode number of embedded slicer bits and positions
 */
typedef enum
{
    TAL_NO_EMBEDDED_SLICER_BITS = 0,       /*!< Disabled all embedded slicer bits  */
    TAL_EMBED_1_SLICERBIT_AT_MSB,          /*!< Embeds 1 slicer bits on I and 1 slicer bits on Q and the MSB position in the data frame */
    TAL_EMBED_1_SLICERBIT_AT_LSB,          /*!< Embeds 1 slicer bits on I and 1 slicer bits on Q and the LSB position in the data frame */
    TAL_EMBED_2_SLICERBITS_AT_MSB,         /*!< Embeds 2 slicer bits on I and 2 slicer bits on Q and the MSB position in the data frame */
    TAL_EMBED_2_SLICERBITS_AT_LSB          /*!< Embeds 2 slicer bits on I and 2 slicer bits on Q and the LSB position in the data frame */
} taliseEmbeddedBits_t;

/**
 *  \brief Enum to hold Talise integer sample resolution
 */
typedef enum
{
    TAL_INTEGER_12BIT_2SCOMP = 0,    /*!< Selects integer sample 12 bit resolution with 2s compliment    */
    TAL_INTEGER_12BIT_SIGNED,        /*!< Selects integer sample 12 bit resolution with signed magnitude */
    TAL_INTEGER_16BIT_2SCOMP,        /*!< Selects integer sample 16 bit resolution with 2s compliment    */
    TAL_INTEGER_16BIT_SIGNED,        /*!< Selects integer sample 16 bit resolution with signed magnitude */
    TAL_INTEGER_24BIT_2SCOMP,        /*!< Selects integer sample 24 bit resolution with 2s compliment    */
    TAL_INTEGER_24BIT_SIGNED         /*!< Selects integer sample 24 bit resolution with signed magnitude */
} taliseIntSampleResolution_t;

/**
*  \brief Data structure to hold Talise Floating Point Formatter Configuration
*/
typedef struct
{
   taliseDataFormattingModes_t formatSelect; /*!< Rx Channel format mode selects */

   /* Float Config Settings */
   taliseFpRoundModes_t fpRoundMode;         /*!< Rounding mode for floating point format (See enum values) */
   uint8_t fpDataFormat;                     /*!< If floating point format is enabled in formatSelect member, this sets the 16 bit output from MSB to LSB, 1 = {Sign, Significand, Exponent}, 0 = {Sign, Exponent, Significand} */
   uint8_t fpEncodeNan;                      /*!< 1 =  encodes the highest value of Exponent to mean NaN (Not a Number) to be compatible to IEEE754 specification (Valid: 0 or 1) */
   taliseFpExponentModes_t fpNumExpBits;     /*!< Indicates the number of exponent and significand bits in the floating point number */
   uint8_t fpHideLeadingOne;                 /*!< 1 =  Hides the leading one in significand to be compatible to the IEEE754 specification. 0 = a leading one exists at the MSB of the significand.  (Valid: 0, 1) */
   taliseFpAttenSteps_t fpRx1Atten;          /*!< Rx1 - Attenuate integer data when floating point mode enabled, see enum for values from 0dB to 42dB in 6dB steps */
   taliseFpAttenSteps_t fpRx2Atten;          /*!< Rx2 - Attenuate integer data when floating point mode enabled, see enum for values from 0dB to 42dB in 6dB steps */

   /* Integer Config Settings */
   taliseEmbeddedBits_t intEmbeddedBits;             /*!< Integer number of embedded bits and position */
   taliseIntSampleResolution_t intSampleResolution;  /*!< Integer sample resolution selecting either 12, 16, 14 bit modes with signed or 2s Complement */

   /* Slicer Config Settings */
   taliseGainStepSize_t extPinStepSize;          /*!< Enum selects the external pin gain step size */
   taliseRx1ExtSlicerGpioSelect_t rx1GpioSelect; /*!< Enum selects the Rx1 GPIO Configuration */
   taliseRx2ExtSlicerGpioSelect_t rx2GpioSelect; /*!< Enum selects the Rx2 GPIO Configuration */
   uint8_t externalLnaGain;                      /*!< Selects Slicer to compensate for external dualband LNA {0 - disabled, 1 - enabled */
   uint8_t tempCompensationEnable;               /*!< Selects Slicer to compensate for temperature variations {0 - disabled, 1 - enabled */
} taliseRxDataFormat_t;

/**
 *  \brief Data structure to hold Talise Rx Gain Control Pin Configuration
 */
typedef struct
{
        uint8_t incStep;                /*!< Increment in gain index applied when the increment gain pin is pulsed. A value of 0 to 7 applies a step size of 1 to 8 */
        uint8_t decStep;                /*!< Decrement in gain index applied when the increment gain pin is pulsed. A value of 0 to 7 applies a step size of 1 to 8 */
        taliseGpioPinSel_t rxGainIncPin;/*!< GPIO used for the Increment gain input: Rx1 : TAL_GPIO_00 or TAL_GPIO_10, Rx2 : TAL_GPIO_03 or TAL_GPIO_13*/
        taliseGpioPinSel_t rxGainDecPin;/*!< GPIO used for the Decrement gain input: Rx1 : TAL_GPIO_01 or TAL_GPIO_11, Rx2 : TAL_GPIO_04 or TAL_GPIO_14*/
        uint8_t enable;                 /*!< Enable (1) or disable (0) the gain pin control*/
} taliseRxGainCtrlPin_t;

/**
 *  \brief Data structure to hold Talise Rx dualband LNA gain table entries
 */
typedef struct
{
    uint8_t dualbandControl;    /*!< The external control value to be output on the 3.3V GPIO?s to control the LNA (values 0-3). */
    uint8_t dualbandGain;       /*!< The gain compensation value for the corresponding external control, used for RSSI and gain compensation.
                                     Range of 0 to 63 (0 to +31.5db in 0.5db steps). */
} taliseDualBandLnaGainTable_t;

typedef enum
{
    TAL_RX1_NCO1A = 0,
    TAL_RX1_NCO1B,
    TAL_RX1_NCO2A,
    TAL_RX1_NCO2B,

    TAL_RX2_NCO1A,
    TAL_RX2_NCO1B,
    TAL_RX2_NCO2A,
    TAL_RX2_NCO2B
} taliseRxNcoChannel_t;

#ifdef __cplusplus
}
#endif

#endif /* TALISE_RX_TYPES_H_ */
/**
 * \file talise_tx_types.h
 * \brief Contains Talise API Tx datapath data types
 *
 * Talise API version: 3.4.0.0
 *
 * Copyright 2015-2017 Analog Devices Inc.
 * Released under the AD9378-AD9379 API license, for more information see the "LICENSE.txt" file in this zip file.
 */

#ifndef TALISE_TX_TYPES_H_
#define TALISE_TX_TYPES_H_

#ifdef __cplusplus
extern "C" {
#endif

/**
 *  \brief Enum of possible Tx channel enables
 */
typedef enum
{
    TAL_TXOFF = 0,      /*!< No Tx channels are enabled */
    TAL_TX1,            /*!< Tx1 channel enabled */
    TAL_TX2,            /*!< Tx2 channel enabled */
    TAL_TX1TX2          /*!< Tx1 + Tx2 channels enabled */
} taliseTxChannels_t;

/**
 *  \brief Enum of possible Tx DAC FS boost options
 */
typedef enum
{
    TAL_DACFS_0DB 	= 0x0,	/*!< No Full Scale Boost */
    TAL_DACFS_3DB	= 0x1F  /*!< Full scale boost = 3dB */
} taliseDacFullScale_t;

/**
 *  \brief Enum to set the Tx Atenuation step size
 */
typedef enum
{
    TAL_TXATTEN_0P05_DB = 0,    /*!< Tx attenuation 0.05dB step size */
    TAL_TXATTEN_0P1_DB = 1,     /*!< Tx attenuation 0.1dB step size */
    TAL_TXATTEN_0P2_DB = 2,     /*!< Tx attenuation 0.2dB step size */
    TAL_TXATTEN_0P4_DB = 3      /*!< Tx attenuation 0.4dB step size */
} taliseTxAttenStepSize_t;

/**
 *  \brief Data structure to hold Talise Tx NCO test tone Configuration
 */
typedef struct
{
        uint8_t enable;                 /*!< 0 = Disable Tx NCO, 1 = Enable Tx NCO on both transmitters */
        int32_t tx1ToneFreq_kHz;        /*!< Signed frequency in kHz of the desired Tx1 tone */
        int32_t tx2ToneFreq_kHz;        /*!< Signed frequency in kHz of the desired Tx2 tone */
} taliseTxNcoTestToneCfg_t;

/**
 *  \brief Data structure to hold Talise Tx Attenuation Control Pin Configuration
 */
typedef struct
{
        uint8_t stepSize;                   /*!< The step that will increase or decrease the channel attenuation. This parameter sets the
                                                 change in Tx attenuation for each increment or decrement signal received in incr/decr mode.
                                                 Step of 1 changes attenuation by 0.05dB. Valid range is from 0 to 31 */
        taliseGpioPinSel_t txAttenIncPin;   /*!< GPIO used to increment Tx attenuation
                                                 Tx1 : TAL_GPIO_04 or TAL_GPIO_12
                                                 Tx2 : TAL_GPIO_06 or TAL_GPIO_14 */
        taliseGpioPinSel_t txAttenDecPin;    /*!< GPIO used to decrement Tx attenuation
                                                 Tx1 : TAL_GPIO_05 or TAL_GPIO_13
                                                 Tx2 : TAL_GPIO_07 or TAL_GPIO_15 */
        uint8_t enable;                     /*!< Enable (1) or disable (0) the attenuation pin control */
} taliseTxAttenCtrlPin_t;

/**
 *  \brief Data structure to hold Talise Tx PA Protection configuration settings
 */
typedef struct
{
        uint8_t avgDuration;          /*!< Number of Tx samples (at JESD204 IQ sample rate) to average for the power measurement.
                                           samples = 2^(avgDuration + 5), 0 = 32 samples, max:14 = 524288 samples */
        uint8_t txAttenStep;          /*!< if PA protection threshold met, Tx Atten = TxAttenSetting + (txAttenStep * 0.4dB) */
        uint16_t tx1PowerThreshold;   /*!< tx1PowerThreashold = round(4096 * 10^(tx1PowerThreshold_dBFS / 10)) (valid 1-8191) */
        uint16_t tx2PowerThreshold;   /*!< tx2PowerThreashold = round(4096 * 10^(tx2PowerThreshold_dBFS / 10)) (valid 1-8191) */

        uint8_t peakCount;            /*!< 0=Peak Mode is disabled, if the Tx peak power threshold is exceeded more than peakCount times within
                                           one average duration, a PA error is flagged (Si Rev 0xB1: 0-30, Si Rev 0xC0: 0-31) */
        uint8_t tx1PeakThreshold;     /*!< 8-bit threshold for Tx1 peak detect. When instantaneous power exceeds this threshold, a peak is registered (valid 1-255)
                                           tx1PeakThreshold = round(128 * 10^(tx1PeakThreshold_dBFS / 10)) */
        uint8_t tx2PeakThreshold;     /*!< 8-bit threshold for Tx2 peak detect. When instantaneous power exceeds this threshold, a peak is registered (valid 1-255)
                                           tx2PeakThreashold = round(128 * 10^(tx2PeakThreshold_dBFS / 10))*/
} taliseTxPaProtectCfg_t;

#ifdef __cplusplus
}
#endif

#endif /* TALISE_TX_TYPES_H_ */
/*!
 * \file talise_types.h
 * \brief Contains Talise API configuration and run-time type definitions
 *
 * Talise API version: 3.4.0.0
 *
 * Copyright 2015-2017 Analog Devices Inc.
 * Released under the AD9378-AD9379 API license, for more information see the "LICENSE.txt" file in this zip file.
 */

#ifndef TALISE_TYPES_H_
#define TALISE_TYPES_H_

#ifdef __cplusplus
extern "C" {
#endif

#include <linux/kernel.h>

#include "talise_rx_types.h"
#include "talise_jesd204_types.h"
#include "talise_tx_types.h"
#include "talise_radioctrl_types.h"

/**
 *  \brief Enum of possible HS divider settings
 */
typedef enum
{
    TAL_HSDIV_2   = 0x0,    /*!< High speed clock divide by 2 setting */
    TAL_HSDIV_2P5 = 0x1,    /*!< High speed clock divide by 2.5 setting */
    TAL_HSDIV_3   = 0x2,    /*!< High speed clock divide by 3 setting */
    TAL_HSDIV_4   = 0x3,    /*!< High speed clock divide by 4 setting */
    TAL_HSDIV_5   = 0x4     /*!< High speed clock divide by 5 setting */
} taliseHsDiv_t;

/**
 * \brief Enum of ORx PLL selections
 */
typedef enum
{
    TAL_OBSLO_RF_PLL = 0,           /*!< Selects RF PLL for Observation LO */
    TAL_OBSLO_AUX_PLL               /*!< Selects AUX PLL for Observation LO */
} taliseObsRxLoSource_t;

/**
 *  \brief Enum to set the desired FIR filter type for related functions
 */
typedef enum
{
    TAL_TX1_FIR = 1,                        /*!< Tx1 FIR filter select */
    TAL_TX2_FIR = 2,                        /*!< Tx2 FIR filter select */
    TAL_TX1TX2_FIR = 3,                     /*!< Tx1 + Tx2 FIR filter select */
    TAL_RX1_FIR = 4,                        /*!< Rx1 FIR filter select */
    TAL_RX2_FIR = 8,                        /*!< Rx2 FIR filter select */
    TAL_RX1RX2_FIR = 12,                    /*!< Rx1 + Rx2 FIR filter select */
    TAL_RX1RX2_LOOPBACK_FIR = 140,          /*!< Rx1 + Rx2 loopback FIR filter select */
    TAL_OBSRX1_FIR = 16,                    /*!< ORx1 FIR filter select */
    TAL_OBSRX2_FIR = 32,                    /*!< ORx2 FIR filter select */
    TAL_OBSRX1RX2_FIR = 48,                 /*!< ORx1 + ORx2 FIR filter select */
    TAL_OBSRX1RX2_LOOPBACK_FIR = 176,       /*!< ORx1 + ORx2 loopback FIR filter select */
    TAL_LOOPBACK_FIR = 128                  /*!< Loopback FIR filter select */
} talisefirName_t;

/**
 *  \brief Enum to select the proper gain for the FIR
 */
typedef enum
{
    TAL_FIR_GAIN_NEG12_DB = -12, /*!< Talise FIR gain -12 */
    TAL_FIR_GAIN_NEG6_DB = -6,   /*!< Talise FIR gain -6 */
    TAL_FIR_GAIN_0_DB = 0,       /*!< Talise FIR gain 0 */
    TAL_FIR_GAIN_POS6_DB = 6     /*!< Talise FIR gain 6 */
} taliseFirGain_t;

/**
 *  \brief Data structure to hold Talise States
 */
typedef enum
{
    TAL_STATE_POWERONRESET = 0x00,
    TAL_STATE_INITIALIZED  = 0x01,
    TAL_STATE_STREAMLOADED = 0x02,
    TAL_STATE_ARMLOADED    = 0x04,
    TAL_STATE_CALS_RUN     = 0x08,
    TAL_STATE_RADIOON      = 0x10
} taliseStates_t;

/**
 *  \brief Enum of possible DDC Modes
 */
typedef enum
{
    TAL_RXDDC_BYPASS = 0,      /*!< No Half Band Enabled */
    TAL_RXDDC_FILTERONLY,      /*!< Half Band Filters only */
    TAL_RXDDC_INT2,            /*!< Half Band Interpolation by 2 */
    TAL_RXDDC_DEC2,            /*!< Half Band Decimate by 2 */
    TAL_RXDDC_BYPASS_REALIF,   /*!< No Half Band Enabled */
    TAL_RXDDC_FILTERONLY_REALIF,     /*!< Half Band Filters only */
    TAL_RXDDC_INT2_REALIF,     /*!< Half Band Interpolation by 2 */
    TAL_RXDDC_DEC2_REALIF      /*!< Half Band Decimate by 2 */
} taliseRxDdc_t;

/**
 * \brief Enumerated list of DDC Modes in ORx datapath
 */
typedef enum
{
    TAL_ORXDDC_DISABLED = 0x00,          /*!< ZIF Observation Receiver */
    TAL_ORXDDC_SUBSAMPLE_BY2             /*!< Subsample Received Observation signal */
} taliseOrxDdc_t;

/**
 * \brief Enumerated list of CMOS pads drive strength options
 */
typedef enum
{
    /* Values encoded as {non_gpio_drv , spi_cmos_drv_select[3:0]} */
    TAL_CMOSPAD_DRV_1X  = 0x00,       /*!<  2.5pF load @ 65MHz */
    TAL_CMOSPAD_DRV_2X  = 0x10,       /*!<    5pF load @ 65MHz */
    TAL_CMOSPAD_DRV_3X  = 0x03,       /*!<  7.5pF load @ 65MHz */
    TAL_CMOSPAD_DRV_4X  = 0x11,       /*!<   10pF load @ 65MHz */
    TAL_CMOSPAD_DRV_5X  = 0x0F,       /*!< 12.5pF load @ 65MHz */
    TAL_CMOSPAD_DRV_6X  = 0x13,       /*!<   15pF load @ 65MHz */
    TAL_CMOSPAD_DRV_8X  = 0x17,       /*!<   20pF load @ 65MHz */
    TAL_CMOSPAD_DRV_10X = 0x1F        /*!<   25pF load @ 65MHz */
} taliseCmosPadDrvStr_t;

/**
 * \brief Enumerated list of options to disable Tx data when PLL unlocks
 */
typedef enum
{
    TAL_TXDIS_TX_NOT_DISABLED       = 0x0,      /*!< Tx data is not disabled when PLL unlocks */
    TAL_TXDIS_TX_ZERO_DATA          = 0x1,      /*!< Tx data is zeroed immediately when PLL unlocks */
    TAL_TXDIS_TX_RAMP_DOWN_TO_ZERO  = 0x2       /*!< Tx data is ramped down to zero when PLL unlocks */
} taliseTxDataIfPllUnlock_t;

/**
 * \brief Enumerated list of RFPLL phase synchronization modes
 *
 * RFPLL Phase sync requires extra time to sync each time the RFPLL frequency
 * is changed. If RFPLL phase sync is not required, it may be desired to
 * disable the feature to allow the RFPLL to lock faster.
 *
 * Depending on the desired accuracy of the RFPLL phase sync, several options
 * are provided.
 */
typedef enum
{
    TAL_RFPLLMCS_NOSYNC = 0,                /*!< Disable RFPLL phase synchronization */
    TAL_RFPLLMCS_INIT_AND_SYNC = 1,         /*!< Enable RFPLL phase sync init only */
    TAL_RFPLLMCS_INIT_AND_1TRACK = 2,       /*!< Enable RFPLL phase sync init and track once  */
    TAL_RFPLLMCS_INIT_AND_CONTTRACK = 3     /*!< Enable RFPLL phase sync init and track continuously */
} taliseRfPllMcs_t;

/**
 *  \brief Data structure to hold Talise FIR filter settings
 */
typedef struct
{
    int8_t gain_dB;         /*!< Filter gain in dB */
    uint8_t numFirCoefs;    /*!< Number of coefficients in the FIR filter */
    int16_t *coefs;         /*!< A pointer to an array of filter coefficients */
} taliseFir_t;

/**
 *  \brief Data structure to hold Talise Rx NCO shifter parameters for both BandA and BandB
 *  configurations.  Settings all four element values to zero for a band will disable the NCO
 *  for that shift.
 */
typedef struct
{
    uint32_t bandAInputBandWidth_kHz;  /*!< BandWidth in khz of the BandA input signal */
    int32_t bandAInputCenterFreq_kHz;      /*!< Center Frequency in khz of the BandA input signal */
    int32_t bandANco1Freq_kHz;         /*!< BandA NCO1 Frequency shift in khz */
    int32_t bandANco2Freq_kHz;         /*!< BandA NCO2 Frequency shift in khz */

    uint32_t bandBInputBandWidth_kHz;  /*!< BandWidth in khz of the BandB input signal */
    int32_t bandBInputCenterFreq_kHz;  /*!< Center Frequency in khz of the BandB input signal */
    int32_t bandBNco1Freq_kHz;         /*!< BandB NCO1 Frequency shift in khz */
    int32_t bandBNco2Freq_kHz;         /*!< BandB NCO2 Frequency shift in khz */

} taliseRxNcoShifterCfg_t;

/**
 *  \brief Data structure to hold settings for the current Rx specific use case profile
 */
typedef struct
{
    taliseFir_t rxFir;			        /*!< Rx FIR filter structure */
    uint8_t rxFirDecimation;            /*!< Rx FIR decimation (1,2,4) */
    uint8_t rxDec5Decimation;           /*!< Decimation of Dec5 or Dec4 filter (5,4) */
    uint8_t rhb1Decimation;             /*!< RX Halfband1 (HB1) decimation. Can be either 1 or 2 */
    uint32_t rxOutputRate_kHz;          /*!< Rx Output data rate in kHz */
    uint32_t rfBandwidth_Hz;            /*!< Rx RF passband bandwidth for the profile */
    uint32_t rxBbf3dBCorner_kHz;        /*!< Rx BBF (TIA) 3dB corner in kHz */
    uint16_t rxAdcProfile[42];          /*!< Rx ADC Profile - tunes the bandwidth of the passband and noise transfer functions of the ADC */
    taliseRxDdc_t rxDdcMode;            /*!< Rx DDC mode */
    taliseRxNcoShifterCfg_t rxNcoShifterCfg; /*!< Rx NCO Shift parameters used for ZIF->RIF, CIF->ZIF */
} taliseRxProfile_t;

/**
 *  \brief Data structure to hold settings for the current ORx specific use case profile
 */
typedef struct
{
    taliseFir_t rxFir;                  /*!< ORx FIR filter structure */
    uint8_t rxFirDecimation;            /*!< ORx FIR decimation (1,2,4) */
    uint8_t rxDec5Decimation;           /*!< Decimation of Dec5 or Dec4 filter (5,4) */
    uint8_t rhb1Decimation;             /*!< ORX Halfband1 (HB1) decimation. Can be either 1 or 2 */
    uint32_t orxOutputRate_kHz;         /*!< ORx Output data rate in kHz */
    uint32_t rfBandwidth_Hz;            /*!< ORx RF passband bandwidth for the profile */
    uint32_t rxBbf3dBCorner_kHz;        /*!< ORx BBF (TIA) 3dB corner in kHz */
    uint16_t orxLowPassAdcProfile[42];  /*!< ORx Lowpass ADC Profile - tunes the bandwidth of the passband and noise transfer functions of the ADC */
    uint16_t orxBandPassAdcProfile[42]; /*!< ORx Bandpass ADC Profile (ADC stitching only) - tunes the bandwidth of the passband and noise transfer functions of the ADC */
    taliseOrxDdc_t orxDdcMode;          /*!< ORx DDC mode */
    int16_t orxMergeFilter[12];         /*!< ORx Merge filter (ADC stitching only) - Merges the Lowpass and Bandpass ADC to obtain a wideband ADC transfer function */
} taliseORxProfile_t;

/**
 *  \brief Data structure to hold settings for the current Tx specific use case profile
 */
typedef struct
{
    uint8_t dacDiv;                     /*!< The divider used to generate the DAC clock (1,2)*/
    taliseFir_t txFir;                  /*!< Tx FIR filter structure */
    uint8_t txFirInterpolation;         /*!< The TX digital FIR filter interpolation (1,2,4) */
    uint8_t thb1Interpolation;          /*!< Tx Halfband1 (HB1) filter interpolation (1,2) */
    uint8_t thb2Interpolation;          /*!< Tx Halfband2 (HB2) filter interpolation (1,2) */
    uint8_t thb3Interpolation;          /*!< Tx Halfband3 (HB3) filter interpolation (1,2) */
    uint8_t txInt5Interpolation;        /*!< Tx Int5 filter interpolation (1,5) */
    uint32_t txInputRate_kHz;           /*!< Tx input data rate in kHz */
    uint32_t primarySigBandwidth_Hz;    /*!< Tx primary signal BW */
    uint32_t rfBandwidth_Hz;            /*!< Tx RF passband bandwidth for the profile */
    uint32_t txDac3dBCorner_kHz;        /*!< DAC filter 3dB corner in kHz */
    uint32_t txBbf3dBCorner_kHz;        /*!< Tx BBF 3dB corner in kHz */
    uint16_t loopBackAdcProfile[42];    /*!< Rx Loop Back ADC profile to set the bandwidth of the ADC response */
} taliseTxProfile_t;

/**
 *  \brief Data structure to hold ORx gain control settings for initialization and during use
 */
typedef struct
{
    taliseGainMode_t gainMode; /*!< Current Rx gain control mode setting */
	uint8_t orx1GainIndex;      /*!< ORx1 Gain Index, can be used in different ways for manual and AGC gain control */
    uint8_t orx2GainIndex;      /*!< ORx2 Gain Index, can be used in different ways for manual and AGC gain control */
    uint8_t orx1MaxGainIndex;       /*!< Max gain index for the currently loaded ORx1 Gain table */
    uint8_t orx1MinGainIndex;       /*!< Min gain index for the currently loaded ORx1 Gain table */
    uint8_t orx2MaxGainIndex;       /*!< Max gain index for the currently loaded ORx2 Gain table */
    uint8_t orx2MinGainIndex;       /*!< Min gain index for the currently loaded ORx2 Gain table */
} taliseORxGainControl_t;

/**
 *  \brief Data structure to hold Rx gain control settings for initialization and during use
 */
typedef struct
{
	taliseGainMode_t gainMode;  /*!< Current Rx gain control mode setting */
    uint8_t rx1GainIndex;       /*!< Rx1 Gain Index, can be used in different ways for manual and AGC gain control */
    uint8_t rx2GainIndex;       /*!< Rx2 Gain Index, can be used in different ways for manual and AGC gain control */
    uint8_t rx1MaxGainIndex;    /*!< Max gain index for the currently loaded Rx1 Gain table */
    uint8_t rx1MinGainIndex;    /*!< Min gain index for the currently loaded Rx1 Gain table */
    uint8_t rx2MaxGainIndex;    /*!< Max gain index for the currently loaded Rx2 Gain table */
    uint8_t rx2MinGainIndex;    /*!< Min gain index for the currently loaded Rx2 Gain table */
} taliseRxGainControl_t;

/**
 *  \brief Data structure to hold Tx data path settings
 */
typedef struct
{
    taliseTxProfile_t txProfile;              /*!< Tx datapath profile, 3dB corner frequencies, and digital filter enables */
    taliseDeframerSel_t deframerSel;          /*!< Talise JESD204b deframer select (Deframer A or B, or both) */
    taliseTxChannels_t txChannels;            /*!< The desired Tx channels to enable during initialization */
    taliseTxAttenStepSize_t txAttenStepSize;  /*!< Tx Attenuation step size */
    uint16_t tx1Atten_mdB;                    /*!< Initial and current Tx1 Attenuation */
    uint16_t tx2Atten_mdB;                    /*!< Initial and current Tx2 Attenuation */
    taliseTxDataIfPllUnlock_t disTxDataIfPllUnlock;   /*!< Options to disable Transmit data when the RFPLL unlocks */
} taliseTxSettings_t;

/**
 *  \brief Data structure to hold Rx data path settings
 */
typedef struct
{
    taliseRxProfile_t rxProfile;        /*!< Rx datapath profile, 3dB corner frequencies, and digital filter enables */
    taliseFramerSel_t framerSel;        /*!< Rx JESD204b framer configuration enum */
    taliseRxGainControl_t rxGainCtrl;   /*!< Rx Gain control settings structure */
    taliseRxChannels_t rxChannels;      /*!< The desired Rx Channels to enable during initialization */
} taliseRxSettings_t;

/**
 *  \brief Data structure to hold ORx data path settings
 */
typedef struct
{
    taliseORxProfile_t orxProfile;               /*!< ORx datapath profile, 3dB corner frequencies, and digital filter enables. */
    taliseORxGainControl_t orxGainCtrl;         /*!< ObsRx gain control settings structure */
    taliseFramerSel_t framerSel;                /*!< ObsRx JESD204b framer configuration structure */
    taliseObsRxChannels_t obsRxChannelsEnable;  /*!< The desired ObsRx Channel to enable during initialization */
    taliseObsRxLoSource_t obsRxLoSource;        /*!< Field not used, reserved for future use. The ORx mixers can use the RF_PLL or Aux_PLL */
} taliseObsRxSettings_t;

/**
 *  \brief Data structure to hold digital clock settings
 */
typedef struct
{
    uint32_t deviceClock_kHz;       /*!< CLKPLL and device reference clock frequency in kHz */
    uint32_t clkPllVcoFreq_kHz;     /*!< CLKPLL VCO frequency in kHz */
    taliseHsDiv_t  clkPllHsDiv;     /*!< CLKPLL high speed clock divider */
    uint8_t rfPllUseExternalLo;     /*!< 1= Use external LO input for RF PLL, 0 = use internal LO generation for RF PLL */
    taliseRfPllMcs_t rfPllPhaseSyncMode;   /*!< Set RF PLL phase synchronization mode. Adds extra time to lock RF PLL when PLL frequency changed. See enum for options */
} taliseDigClocks_t;

/**
 * \brief Data structure used by the API run time state structure to hold the calculated
 *        digital clocks for the selected init profiles
 */
typedef struct
{
    uint32_t deviceClock_kHz;       /*!< CLKPLL and device reference clock frequency in kHz */
    uint32_t clkPllVcoFreq_kHz;     /*!< CLKPLL VCO frequency in kHz */
    taliseHsDiv_t  clkPllHsDiv;     /*!< CLKPLL high speed clock divider */
    uint32_t hsDigClkDiv2_Hz;       /*!< Calculated in TALISE_initialize() digital clock used throughout API functions */
    uint32_t hsDigClkDiv4or5_Hz;    /*!< Calculated in TALISE_initialize() digital clock used throughout API functions */
    uint8_t rfPllUseExternalLo;     /*!< Stored version of the init struct setting (Ext LO input) to keep in the device data structure, 1= Use external LO input for RF PLL, 0 = use internal LO generation for RF PLL */
} taliseClocks_t;

/**
 * \brief Data structure to hold SPI settings for all system device types
 */
typedef struct
{
    uint8_t MSBFirst;                           /*!< 1 = MSBFirst, 0 = LSBFirst */
    uint8_t enSpiStreaming;                     /*!< Not Recommended - most registers in Talise API are not consecutive */
    uint8_t autoIncAddrUp;                      /*!< For SPI Streaming, set address increment direction. 1= next addr = addr+1, 0:addr = addr-1 */
    uint8_t fourWireMode;                       /*!< 1: Use 4-wire SPI, 0: 3-wire SPI (SDIO pin is bidirectional). NOTE: ADI's FPGA platform always uses 4-wire mode */
    taliseCmosPadDrvStr_t cmosPadDrvStrength;   /*!< Drive strength of CMOS pads when used as outputs (SDIO, SDO, GP_INTERRUPT, GPIO 1, GPIO 0) */
} taliseSpiSettings_t;

/**
 * \brief Data Structure to hold Talise device gain settings
 */
typedef struct
{
    uint8_t rx1MinGainIndex;         /*!< Current device minimum Rx1 gain index */
    uint8_t rx1MaxGainIndex;         /*!< Current device maximum Rx1 gain index */
    uint8_t rx2MinGainIndex;         /*!< Current device minimum Rx2 gain index */
    uint8_t rx2MaxGainIndex;         /*!< Current device maximum Rx2 gain index */
    uint8_t orx1MinGainIndex;        /*!< Current device minimum Orx1 gain index */
    uint8_t orx1MaxGainIndex;        /*!< Current device maximum Orx1 gain index */
    uint8_t orx2MinGainIndex;        /*!< Current device minimum Orx2 gain index */
    uint8_t orx2MaxGainIndex;        /*!< Current device maximum Orx2 gain index */
} taliseGainIndex_t;

/**
 * \brief Data structure to hold Talise device instance initialization settings
 */
typedef struct
{
    taliseSpiSettings_t   spiSettings;     /*!< SPI settings data structure */
    taliseRxSettings_t    rx;              /*!< Rx settings data structure */
    taliseTxSettings_t    tx;              /*!< Tx settings data structure */
    taliseObsRxSettings_t obsRx;           /*!< ObsRx settings data structure */
    taliseDigClocks_t     clocks;          /*!< Holds settings for CLKPLL and reference clock */
    taliseJesdSettings_t  jesd204Settings; /*!< Holds the JESD204B data link settings */
} taliseInit_t;

/**
 * \brief Data structure to hold Talise error callback function
 */
typedef struct
{
    uint32_t errSrc;
    const char* (*callbackFunction)(uint32_t errSrc, uint32_t errCode);
} talErrorFunction_t;

#define TALISE_ERRORFUNCTIONTABLEMAX 2

/**
 * \brief Function jump table to hold a registry of error message functions for
 *        add on features.
 */
typedef struct
{
    talErrorFunction_t talErrorFunctionTable[TALISE_ERRORFUNCTIONTABLEMAX];
} talErrFunctionTable_t;

/**
 * \brief Structure to hold FHM mode frequency range
 */
typedef struct
{
    uint32_t fhmMinFreq_MHz; /*!< Lower limit for FHM hop frequency in MHz */
    uint32_t fhmMaxFreq_MHz; /*!< Upper limit for FHM hop frequency in MHz */
} talFrequencyHoppingRange_t;

/**
 * \brief Data structure to hold a Talise device instance status information
 */
typedef struct
{
    taliseStates_t devState;          			/*!< Current device state of the part, i.e., radio on, radio off, arm loaded, etc., defined by deviceState enum */
    uint8_t initializedChannels;                /*!< Holds Rx/ORx/Tx channels that were initialized and calibrated for the current device */
    uint8_t profilesValid;            			/*!< Current device profilesValid bit field for use notification, i.e., Tx = 0x01, Rx = 0x02, Orx = 0x04 */
    uint32_t errSource;               			/*!< Current source of error returned */
    uint32_t errCode;                 			/*!< Current error code returned */
    taliseClocks_t clocks;            			/*!< Currently calculated Talise digital clocks for the selected init profiles */
    taliseGainMode_t gainMode;        			/*!< Current device gain mode, which can be MGC, AGCFAST, AGCSLOW, or HYBRID */
    taliseGainIndex_t gainIndexes;    			/*!< Current device gain index values */
    taliseTxAttenStepSize_t txAttenStepSize; 	/*!< Current tx Atten step size */
    uint8_t orxAdcStitchingEnabled;             /*!< TALISE_initialize sets to 1 if ORx ADC stitching enabled, 0 if not required */
    uint32_t usedGpiopins;                      /*!< Each bit position 'N' indicates whether the GPIO 'N' is assigned to some function (if 1) or not (if 0) */
    uint16_t usedGpio3p3pins;                   /*!< Each bit position 'N' indicates whether the GPIO3.3 'N' is assigned to some function (if 1) or not (if 0) */
    uint8_t rxFramerNp;                         /*!< Rx Framer Np - converter sample resolution (12, 16, 24) */
    uint8_t orxFramerNp;                        /*!< ORx Framer Np - converter sample resolution (12, 16, 24) */
    uint32_t rxOutputRate_kHz;                  /*!< Rx Output data rate in kHz */
    uint32_t txInputRate_kHz;                   /*!< Tx input data rate in kHz */
    taliseRxDdc_t rxDdcMode;                    /*!< DDC Mode saved from initialization  */
    uint8_t rxDualBandEnabled;                  /*!< DualBand Mode saved from initialization for determining dualband status */
    uint8_t rxTotalM;                           /*!< Value of M saved from initialization  */
    uint32_t rxBandwidth_Hz;                    /*!< Rx Bandwidth from the current profile */
    uint32_t txBandwidth_Hz;                    /*!< Tx Bandwidth from the current profile */
    uint32_t orxBandwidth_Hz;                   /*!< ORx Bandwidth from the current profile */
    uint32_t swTest;                            /*!< Software testmode signal */
    uint8_t deviceSiRev;                        /*!< Talise silicon rev read during TALISE_initialize */
    talErrFunctionTable_t talErrFunctionTable;  /*!< Talise  callback function table */
    talFrequencyHoppingRange_t talFhmFreqRange; /*!< Talise FHM frequency range */
    taliseFhmTriggerMode_t talFhmTriggerMode;   /*!< Talise frequency hop trigger mode */
    uint64_t talFhmInitHopFreq_Hz;              /*!< Initial Talise hop frequency */
    uint8_t talFhmMcsSync;                      /*!< Flag to indicate if MCS synchronization is enabled on frequency hopping */
} taliseInfo_t;

/**
 * \brief Data structure to hold Talise device instance settings
 */
typedef struct
{
    void *devHalInfo;               /*!< ADI_HAL Hardware layer settings pointer specific to this Talise instance */
    taliseInfo_t devStateInfo;      /*!< Talise infomration container */
} taliseDevice_t;

#ifdef __cplusplus
}
#endif

#endif
